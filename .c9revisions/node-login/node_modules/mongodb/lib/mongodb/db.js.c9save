{"ts":1354675506435,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Module dependencies.\n * @ignore\n */\nvar QueryCommand = require('./commands/query_command').QueryCommand,\n  DbCommand = require('./commands/db_command').DbCommand,\n  MongoReply = require('./responses/mongo_reply').MongoReply,\n  Admin = require('./admin').Admin,\n  Collection = require('./collection').Collection,\n  Server = require('./connection/server').Server,\n  ReplSet = require('./connection/repl_set').ReplSet,\n  ReadPreference = require('./connection/read_preference').ReadPreference,\n  Mongos = require('./connection/mongos').Mongos,\n  Cursor = require('./cursor').Cursor,\n  EventEmitter = require('events').EventEmitter,\n  inherits = require('util').inherits,\n  crypto = require('crypto'),\n  parse = require('./connection/url_parser').parse;\n\n/**\n * Internal class for callback storage\n * @ignore\n */\nvar CallbackStore = function() {\n  // Make class an event emitter\n  EventEmitter.call(this);\n  // Add a info about call variable\n  this._notReplied = {};\n}\n\n/**\n * @ignore\n */\ninherits(CallbackStore, EventEmitter);\n\n/**\n * Create a new Db instance.\n *\n * Options\n *  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n *  - **native_parser** {Boolean, default:false}, use c++ bson parser.\n *  - **forceServerObjectId** {Boolean, default:false}, force server to create _id fields instead of client.\n *  - **pkFactory** {Object}, object overriding the basic ObjectID primary key generation.\n *  - **serializeFunctions** {Boolean, default:false}, serialize functions.\n *  - **raw** {Boolean, default:false}, peform operations using raw bson buffers.\n *  - **recordQueryStats** {Boolean, default:false}, record query statistics during execution.\n *  - **retryMiliSeconds** {Number, default:5000}, number of miliseconds between retries.\n *  - **numberOfRetries** {Number, default:5}, number of retries off connection.\n *  - **logger** {Object, default:null}, an object representing a logger that you want to use, needs to support functions debug, log, error **({error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}})**.\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @class Represents a Db\n * @param {String} databaseName name of the database.\n * @param {Object} serverConfig server config object.\n * @param {Object} [options] additional options for the collection.\n */\nfunction Db(databaseName, serverConfig, options) {\n  if(!(this instanceof Db)) return new Db(databaseName, serverConfig, options);\n\n  EventEmitter.call(this);\n  this.databaseName = databaseName;\n  this.serverConfig = serverConfig;\n  this.options = options == null ? {} : options;\n  // State to check against if the user force closed db\n  this._applicationClosed = false;\n  // Fetch the override flag if any\n  var overrideUsedFlag = this.options['override_used_flag'] == null ? false : this.options['override_used_flag'];\n\n  // Verify that nobody is using this config\n  if(!overrideUsedFlag && typeof this.serverConfig == 'object' && this.serverConfig._isUsed && this.serverConfig._isUsed()) {    \n    throw new Error(\"A Server or ReplSet instance cannot be shared across multiple Db instances\");\n  } else if(!overrideUsedFlag && typeof this.serverConfig == 'object'){\n    // Set being used\n    this.serverConfig._used = true;\n  }\n\n  // Ensure we have a valid db name\n  validateDatabaseName(databaseName);\n\n  // Contains all the connections for the db\n  try {\n    this.native_parser = this.options.native_parser;\n    // The bson lib\n    var bsonLib = this.bsonLib = this.options.native_parser ? require('bson').BSONNative : require('bson').BSONPure;\n    // Fetch the serializer object\n    var BSON = bsonLib.BSON;\n    // Create a new instance\n    this.bson = new BSON([bsonLib.Long, bsonLib.ObjectID, bsonLib.Binary, bsonLib.Code, bsonLib.DBRef, bsonLib.Symbol, bsonLib.Double, bsonLib.Timestamp, bsonLib.MaxKey, bsonLib.MinKey]);\n    // Backward compatibility to access types\n    this.bson_deserializer = bsonLib;\n    this.bson_serializer = bsonLib;\n  } catch (err) {\n    // If we tried to instantiate the native driver\n    var msg = \"Native bson parser not compiled, please compile \"\n            + \"or avoid using native_parser=true\";\n    throw Error(msg);\n  }\n\n  // Internal state of the server\n  this._state = 'disconnected';\n\n  this.pkFactory = this.options.pk == null ? bsonLib.ObjectID : this.options.pk;\n  this.forceServerObjectId = this.options.forceServerObjectId != null ? this.options.forceServerObjectId : false;\n\n  // Added safe\n  this.safe = this.options.safe == null ? false : this.options.safe;  \n\n  // If we have not specified a \"safe mode\" we just print a warning to the console\n  if(this.options.safe == null && this.options.w == null && this.options.journal == null && this.options.fsync == null) {\n    console.log(\"========================================================================================\");\n    console.log(\"=  Please ensure that you set the default write concern for the database by setting    =\");\n    console.log(\"=   one of the options                                                                 =\");\n    console.log(\"=                                                                                      =\");\n    console.log(\"=     w: (value of > -1 or the string 'majority'), where < 1 means                     =\");\n    console.log(\"=        no write acknowlegement                                                       =\");\n    console.log(\"=     journal: true/false, wait for flush to journal before acknowlegement             =\");\n    console.log(\"=     fsync: true/false, wait for flush to file system before acknowlegement           =\");\n    console.log(\"=                                                                                      =\");\n    console.log(\"=  For backward compatibility safe is still supported and                              =\");\n    console.log(\"=   allows values of [true | false | {j:true} | {w:n, wtimeout:n} | {fsync:true}]      =\");\n    console.log(\"=   the default value is false which means the driver receives does not                =\");\n    console.log(\"=   return the information of the success/error of the insert/update/remove            =\");\n    console.log(\"=                                                                                      =\");\n    console.log(\"=   ex: new Db(new Server('localhost', 27017), {safe:false})                           =\");\n    console.log(\"=                                                                                      =\");\n    console.log(\"=   http://www.mongodb.org/display/DOCS/getLastError+Command                           =\");\n    console.log(\"=                                                                                      =\");\n    console.log(\"=  The default of no acknowlegement will change in the very near future                =\");\n    console.log(\"=                                                                                      =\");\n    console.log(\"=  This message will disappear when the default safe is set on the driver Db           =\");\n    console.log(\"========================================================================================\");\n  }\n\n  // Internal states variables\n  this.notReplied ={};\n  this.isInitializing = true;\n  this.auths = [];\n  this.openCalled = false;\n\n  // Command queue, keeps a list of incoming commands that need to be executed once the connection is up\n  this.commands = [];\n\n  // Contains all the callbacks\n  this._callBackStore = new CallbackStore();\n\n  // Set up logger\n  this.logger = this.options.logger != null\n    && (typeof this.options.logger.debug == 'function')\n    && (typeof this.options.logger.error == 'function')\n    && (typeof this.options.logger.log == 'function')\n      ? this.options.logger : {error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}};\n  // Allow slaveOk\n  this.slaveOk = this.options[\"slave_ok\"] == null ? false : this.options[\"slave_ok\"];\n\n  var self = this;\n  // Associate the logger with the server config\n  this.serverConfig.logger = this.logger;\n  this.tag = new Date().getTime();\n  // Just keeps list of events we allow\n  this.eventHandlers = {error:[], parseError:[], poolReady:[], message:[], close:[]};\n\n  // Controls serialization options\n  this.serializeFunctions = this.options.serializeFunctions != null ? this.options.serializeFunctions : false;\n\n  // Raw mode\n  this.raw = this.options.raw != null ? this.options.raw : false;\n\n  // Record query stats\n  this.recordQueryStats = this.options.recordQueryStats != null ? this.options.recordQueryStats : false;\n\n  // If we have server stats let's make sure the driver objects have it enabled\n  if(this.recordQueryStats == true) {\n    this.serverConfig.enableRecordQueryStats(true);\n  }\n\n  // Retry information\n  this.retryMiliSeconds = this.options.retryMiliSeconds != null ? this.options.retryMiliSeconds : 1000;\n  this.numberOfRetries = this.options.numberOfRetries != null ? this.options.numberOfRetries : 60;\n\n  // Set default read preference if any\n  this.readPreference = this.options.readPreference;\n};\n\n/**\n * @ignore\n */\nfunction validateDatabaseName(databaseName) {\n  if(typeof databaseName !== 'string') throw new Error(\"database name must be a string\");\n  if(databaseName.length === 0) throw new Error(\"database name cannot be the empty string\");\n\n  var invalidChars = [\" \", \".\", \"$\", \"/\", \"\\\\\"];\n  for(var i = 0; i < invalidChars.length; i++) {\n    if(databaseName.indexOf(invalidChars[i]) != -1) throw new Error(\"database names cannot contain the character '\" + invalidChars[i] + \"'\");\n  }\n}\n\n/**\n * @ignore\n */\ninherits(Db, EventEmitter);\n\n/**\n * Initialize the database connection.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the index information or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.open = function(callback) {\n  var self = this;\n\n  // Check that the user has not called this twice\n  if(this.openCalled) {\n    // Close db\n    this.close();\n    // Throw error\n    throw new Error(\"db object already connecting, open cannot be called multiple times\");\n  }\n\n  // If we have a specified read preference\n  if(this.readPreference != null) this.serverConfig.setReadPreference(this.readPreference);\n\n  // Set that db has been opened\n  this.openCalled = true;\n  // Set the status of the server\n  self._state = 'connecting';\n  // Set up connections\n  if(self.serverConfig instanceof Server || self.serverConfig instanceof ReplSet || self.serverConfig instanceof Mongos) {\n    self.serverConfig.connect(self, {firstCall: true}, function(err, result) {\n      if(err != null) {\n        // Set that db has been closed\n        self.openCalled = false;\n        // Return error from connection\n        return callback(err, null);\n      }\n      // Set the status of the server\n      self._state = 'connected';\n      // Callback\n      return callback(null, self);\n    });\n  } else {\n    return callback(Error(\"Server parameter must be of type Server, ReplSet or Mongos\"), null);\n  }\n};\n\n/**\n * Create a new Db instance sharing the current socket connections.\n *\n * @param {String} dbName the name of the database we want to use.\n * @return {Db} a db instance using the new database.\n * @api public\n */\nDb.prototype.db = function(dbName) {\n  // Copy the options and add out internal override of the not shared flag\n  var options = {};\n  for(var key in this.options) {\n    options[key] = this.options[key];\n  }\n  // Add override flag\n  options['override_used_flag'] = true;\n  // Create a new db instance\n  var newDbInstance = new Db(dbName, this.serverConfig, options);\n  //copy over any auths, we may need them for reconnecting\n  if (this.serverConfig.db) {\n    newDbInstance.auths = this.serverConfig.db.auths;\n  }\n  // Add the instance to the list of approved db instances\n  var allServerInstances = this.serverConfig.allServerInstances();\n  // Add ourselves to all server callback instances\n  for(var i = 0; i < allServerInstances.length; i++) {\n    var server = allServerInstances[i];\n    server.dbInstances.push(newDbInstance);\n  }\n  // Return new db object\n  return newDbInstance;\n}\n\n/**\n * Close the current db connection, including all the child db instances. Emits close event if no callback is provided.\n *\n * @param {Boolean} [forceClose] connection can never be reused.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.close = function(forceClose, callback) {\n  var self = this;\n  // Ensure we force close all connections\n  this._applicationClosed = false;\n\n  if(typeof forceClose == 'function') {\n    callback = forceClose;\n  } else if(typeof forceClose == 'boolean') {\n    this._applicationClosed = forceClose;\n  }\n\n  // Remove all listeners and close the connection\n  this.serverConfig.close(function(err, result) {\n    // Emit the close event\n    if(typeof callback !== 'function') self.emit(\"close\");\n\n    // Emit close event across all db instances sharing the sockets\n    var allServerInstances = self.serverConfig.allServerInstances();\n    // Fetch the first server instance\n    if(Array.isArray(allServerInstances) && allServerInstances.length > 0) {\n      var server = allServerInstances[0];\n      // For all db instances signal all db instances\n      if(Array.isArray(server.dbInstances) && server.dbInstances.length > 1) {\n    \t  for(var i = 0; i < server.dbInstances.length; i++) {\n          var dbInstance = server.dbInstances[i];\n          // Check if it's our current db instance and skip if it is\n          if(dbInstance.databaseName !== self.databaseName && dbInstance.tag !== self.tag) {\n            server.dbInstances[i].emit(\"close\");\n          }\n        }\n      }\n    }\n\n    // Remove all listeners\n    self.removeAllEventListeners();\n    // You can reuse the db as everything is shut down\n    self.openCalled = false;\n    // If we have a callback call it\n    if(callback) callback(err, result);\n  });\n};\n\n/**\n * Access the Admin database\n *\n * @param {Function} [callback] returns the results.\n * @return {Admin} the admin db object.\n * @api public\n */\nDb.prototype.admin = function(callback) {\n  if(callback == null) return new Admin(this);\n  callback(null, new Admin(this));\n};\n\n/**\n * Returns a cursor to all the collection information.\n *\n * @param {String} [collectionName] the collection name we wish to retrieve the information from.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the options or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.collectionsInfo = function(collectionName, callback) {\n  if(callback == null && typeof collectionName == 'function') { callback = collectionName; collectionName = null; }\n  // Create selector\n  var selector = {};\n  // If we are limiting the access to a specific collection name\n  if(collectionName != null) selector.name = this.databaseName + \".\" + collectionName;\n\n  // Return Cursor\n  // callback for backward compatibility\n  if(callback) {\n    callback(null, new Cursor(this, new Collection(this, DbCommand.SYSTEM_NAMESPACE_COLLECTION), selector));\n  } else {\n    return new Cursor(this, new Collection(this, DbCommand.SYSTEM_NAMESPACE_COLLECTION), selector);\n  }\n};\n\n/**\n * Get the list of all collection names for the specified db\n *\n * Options\n *  - **namesOnly** {String, default:false}, Return only the full collection namespace.\n *\n * @param {String} [collectionName] the collection name we wish to filter by.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the collection names or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.collectionNames = function(collectionName, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  collectionName = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : {};\n\n  // Ensure no breaking behavior\n  if(collectionName != null && typeof collectionName == 'object') {\n    options = collectionName;\n    collectionName = null;\n  }\n\n  // Let's make our own callback to reuse the existing collections info method\n  self.collectionsInfo(collectionName, function(err, cursor) {\n    if(err != null) return callback(err, null);\n\n    cursor.toArray(function(err, documents) {\n      if(err != null) return callback(err, null);\n\n      // List of result documents that have been filtered\n      var filtered_documents = documents.filter(function(document) {\n        return !(document.name.indexOf(self.databaseName) == -1 || document.name.indexOf('$') != -1);\n      });\n\n      // If we are returning only the names\n      if(options.namesOnly) {\n        filtered_documents = filtered_documents.map(function(document) { return document.name });\n      }\n\n      // Return filtered items\n      callback(null, filtered_documents);\n    });\n  });\n};\n\n/**\n * Fetch a specific collection (containing the actual collection information)\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **serializeFunctions** {Boolean, default:false}, serialize functions on the document.\n *  - **raw** {Boolean, default:false}, perform all operations using raw bson objects.\n *  - **pkFactory** {Object}, object overriding the basic ObjectID primary key generation.\n *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n *  - **strict**, (Boolean, default:false) throws and error if collection already exists\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n *\n * @param {String} collectionName the collection name we wish to access.\n * @param {Object} [options] returns option results.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the collection or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.collection = function(collectionName, options, callback) {\n  var self = this;\n  if(typeof options === \"function\") { callback = options; options = {}; }\n  // Execute safe\n\n  if(options && (options.strict)) {\n    self.collectionNames(collectionName, function(err, collections) {\n      if(err != null) return callback(err, null);\n\n      if(collections.length == 0) {\n        return callback(new Error(\"Collection \" + collectionName + \" does not exist. Currently in safe mode.\"), null);\n      } else {\n        try {\n          var collection = new Collection(self, collectionName, self.pkFactory, options);\n        } catch(err) {\n          return callback(err, null);\n        }\n        return callback(null, collection);\n      }\n    });\n  } else {\n    try {\n      var collection = new Collection(self, collectionName, self.pkFactory, options);\n    } catch(err) {\n      if(callback == null) {\n        throw err;\n      } else {\n        return callback(err, null);\n      }\n    }\n\n    // If we have no callback return collection object\n    return callback == null ? collection : callback(null, collection);\n  }\n};\n\n/**\n * Fetch all collections for the current db.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the collections or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.collections = function(callback) {\n  var self = this;\n  // Let's get the collection names\n  self.collectionNames(function(err, documents) {\n    if(err != null) return callback(err, null);\n    var collections = [];\n    documents.forEach(function(document) {\n      collections.push(new Collection(self, document.name.replace(self.databaseName + \".\", ''), self.pkFactory));\n    });\n    // Return the collection objects\n    callback(null, collections);\n  });\n};\n\n/**\n * Evaluate javascript on the server\n *\n * Options\n *  - **nolock** {Boolean, default:false}, Tell MongoDB not to block on the evaulation of the javascript.\n *\n * @param {Code} code javascript to execute on server.\n * @param {Object|Array} [parameters] the parameters for the call.\n * @param {Object} [options] the options\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from eval or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.eval = function(code, parameters, options, callback) {\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  parameters = args.length ? args.shift() : parameters;\n  options = args.length ? args.shift() : {};\n\n  var finalCode = code;\n  var finalParameters = [];\n  // If not a code object translate to one\n  if(!(finalCode instanceof this.bsonLib.Code)) {\n    finalCode = new this.bsonLib.Code(finalCode);\n  }\n\n  // Ensure the parameters are correct\n  if(parameters != null && parameters.constructor != Array && typeof parameters !== 'function') {\n    finalParameters = [parameters];\n  } else if(parameters != null && parameters.constructor == Array && typeof parameters !== 'function') {\n    finalParameters = parameters;\n  }\n\n  // Create execution selector\n  var selector = {'$eval':finalCode, 'args':finalParameters};\n  // Check if the nolock parameter is passed in\n  if(options['nolock']) {\n    selector['nolock'] = options['nolock'];\n  }\n\n  // Set primary read preference\n  options.readPreference = ReadPreference.PRIMARY;\n\n  // Execute the eval\n  this.collection(DbCommand.SYSTEM_COMMAND_COLLECTION).findOne(selector, options, function(err, result) {\n    if(err) return callback(err);\n\n    if(result && result.ok == 1) {\n      callback(null, result.retval);\n    } else if(result) {\n      callback(new Error(\"eval failed: \" + result.errmsg), null); return;\n    } else {\n      callback(err, result);\n    }\n  });\n};\n\n/**\n * Dereference a dbref, against a db\n *\n * @param {DBRef} dbRef db reference object we wish to resolve.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from dereference or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.dereference = function(dbRef, callback) {\n  var db = this;\n  // If we have a db reference then let's get the db first\n  if(dbRef.db != null) db = this.db(dbRef.db);\n  // Fetch the collection and find the reference\n  var collection = db.collection(dbRef.namespace);\n  collection.findOne({'_id':dbRef.oid}, function(err, result) {\n    callback(err, result);\n  });\n};\n\n/**\n * Logout user from server, fire off on all connections and remove all auth info\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from logout or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.logout = function(options, callback) {\n  var self = this;\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  // Number of connections we need to logout from\n  var numberOfConnections = this.serverConfig.allRawConnections().length;\n\n  // Let's generate the logout command object\n  var logoutCommand = DbCommand.logoutCommand(self, {logout:1}, options);\n  self._executeQueryCommand(logoutCommand, {onAll:true}, function(err, result) {\n    // Count down\n    numberOfConnections = numberOfConnections - 1;\n    // Work around the case where the number of connections are 0\n    if(numberOfConnections <= 0 && typeof callback == 'function') {\n      var internalCallback = callback;\n      callback = null;\n      // Reset auth\n      self.auths = [];\n      // Handle any errors\n      if(err == null && result.documents[0].ok == 1) {\n        internalCallback(null, true);\n      } else {\n        err != null ? internalCallback(err, false) : internalCallback(new Error(result.documents[0].errmsg), false);\n      }\n    }\n  });\n}\n\n/**\n * Authenticate a user against the server.\n *\n * Options\n *  - **authdb** {String}, The database that the credentials are for,\n *    different from the name of the current DB, for example admin\n * @param {String} username username.\n * @param {String} password password.\n * @param {Object} [options] the options\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from authentication or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.authenticate = function(username, password, options, callback) {\n  var self = this;\n\n  if (typeof callback === 'undefined') {\n    callback = options;\n    options = {};\n  }\n  // the default db to authenticate against is 'this'\n  // if authententicate is called from a retry context, it may be another one, like admin\n  var authdb = options.authdb ? options.authdb : self.databaseName;\n\n  // Push the new auth if we have no previous record\n  // Get the amount of connections in the pool to ensure we have authenticated all comments\n  var numberOfConnections = this.serverConfig.allRawConnections().length;\n  var errorObject = null;\n\n  // Execute all four\n  this._executeQueryCommand(DbCommand.createGetNonceCommand(self), {onAll:true}, function(err, result, connection) {\n    // Execute on all the connections\n    if(err == null) {\n      // Nonce used to make authentication request with md5 hash\n      var nonce = result.documents[0].nonce;\n      // Execute command\n      self._executeQueryCommand(DbCommand.createAuthenticationCommand(self, username, password, nonce, authdb), {connection:connection}, function(err, result) {\n        // Count down\n        numberOfConnections = numberOfConnections - 1;\n        // Ensure we save any error\n        if(err) {\n          errorObject = err;\n        } else if(result.documents[0].err != null || result.documents[0].errmsg != null){\n          errorObject = self.wrap(result.documents[0]);\n        }\n\n        // Work around the case where the number of connections are 0\n        if(numberOfConnections <= 0 && typeof callback == 'function') {\n          var internalCallback = callback;\n          callback = null;\n\n          if(errorObject == null && result.documents[0].ok == 1) {\n            // We authenticated correctly save the credentials\n            self.auths = [{'username':username, 'password':password, 'authdb': authdb}];\n            // Return callback\n            internalCallback(errorObject, true);\n          } else {\n            internalCallback(errorObject, false);\n          }\n        }\n      });\n    }\n  });\n};\n\n/**\n * Add a user to the database.\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {String} username username.\n * @param {String} password password.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from addUser or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.addUser = function(username, password, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  // Figure out the safe mode settings\n  var safe = self.safe != null && self.safe == false ? {w: 1} : self.safe;\n  // Override with options passed in if applicable\n  safe = options != null && options['safe'] != null ? options['safe'] : safe;\n  // Ensure it's at least set to safe\n  safe = safe == null ? {w: 1} : safe;\n  // Use node md5 generator\n  var md5 = crypto.createHash('md5');\n  // Generate keys used for authentication\n  md5.update(username + \":mongo:\" + password);\n  var userPassword = md5.digest('hex');\n  // Fetch a user collection\n  var collection = this.collection(DbCommand.SYSTEM_USER_COLLECTION);\n  // Check if we are inserting the first user\n  collection.count({}, function(err, count) {\n    // We got an error (f.ex not authorized)\n    if(err != null) return callback(err, null);\n    // Check if the user exists and update i\n    collection.find({user: username}, {dbName: options['dbName']}).toArray(function(err, documents) {\n      // We got an error (f.ex not authorized)\n      if(err != null) return callback(err, null);\n      // Add command keys\n      var commandOptions = safe;\n      commandOptions.dbName = options['dbName'];\n      commandOptions.upsert = true;\n      // We have a user, let's update the password or upsert if not\n      collection.update({user: username},{$set: {user: username, pwd: userPassword}}, commandOptions, function(err, results) {\n        if(count == 0 && err) {\n          callback(null, [{user:username, pwd:userPassword}]);\n        } else if(err) {\n          callback(err, null)\n        } else {\n          callback(null, [{user:username, pwd:userPassword}]);\n        }\n      });\n    });\n  });\n};\n\n/**\n * Remove a user from a database\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {String} username username.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from removeUser or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.removeUser = function(username, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  // Figure out the safe mode settings\n  var safe = self.safe != null && self.safe == false ? {w: 1} : self.safe;\n  // Override with options passed in if applicable\n  safe = options != null && options['safe'] != null ? options['safe'] : safe;\n  // Ensure it's at least set to safe\n  safe = safe == null ? {w: 1} : safe;\n\n  // Fetch a user collection\n  var collection = this.collection(DbCommand.SYSTEM_USER_COLLECTION);\n  collection.findOne({user: username}, {dbName: options['dbName']}, function(err, user) {\n    if(user != null) {\n      // Add command keys\n      var commandOptions = safe;\n      commandOptions.dbName = options['dbName'];\n\n      collection.remove({user: username}, commandOptions, function(err, result) {\n        callback(err, true);\n      });\n    } else {\n      callback(err, false);\n    }\n  });\n};\n\n/**\n * Creates a collection on a server pre-allocating space, need to create f.ex capped collections.\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **serializeFunctions** {Boolean, default:false}, serialize functions on the document.\n *  - **raw** {Boolean, default:false}, perform all operations using raw bson objects.\n *  - **pkFactory** {Object}, object overriding the basic ObjectID primary key generation.\n *  - **capped** {Boolean, default:false}, create a capped collection.\n *  - **size** {Number}, the size of the capped collection in bytes.\n *  - **max** {Number}, the maximum number of documents in the capped collection.\n *  - **autoIndexId** {Boolean, default:false}, create an index on the _id field of the document, not created automatically on capped collections.\n *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n *  - **strict**, (Boolean, default:false) throws and error if collection already exists\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {String} collectionName the collection name we wish to access.\n * @param {Object} [options] returns option results.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from createCollection or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.createCollection = function(collectionName, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : null;\n  var self = this;\n\n  // Figure out the safe mode settings\n  var safe = self.safe != null && self.safe == false ? {w: 1} : self.safe;\n  // Override with options passed in if applicable\n  safe = options != null && options['safe'] != null ? options['safe'] : safe;\n  // Ensure it's at least set to safe\n  safe = safe == null ? {w: 1} : safe;\n\n  // Check if we have the name\n  this.collectionNames(collectionName, function(err, collections) {\n    if(err != null) return callback(err, null);\n\n    var found = false;\n    collections.forEach(function(collection) {\n      if(collection.name == self.databaseName + \".\" + collectionName) found = true;\n    });\n\n    // If the collection exists either throw an exception (if db in safe mode) or return the existing collection\n    if(found && options && options.strict) {\n      return callback(new Error(\"Collection \" + collectionName + \" already exists. Currently in safe mode.\"), null);\n    } else if(found){\n      try {\n        var collection = new Collection(self, collectionName, self.pkFactory, options);\n      } catch(err) {\n        return callback(err, null);\n      }\n      return callback(null, collection);\n    }\n\n    // Create a new collection and return it\n    self._executeQueryCommand(DbCommand.createCreateCollectionCommand(self, collectionName, options), {read:false, safe:safe}, function(err, result) {\n      var document = result.documents[0];\n      // If we have no error let's return the collection\n      if(err == null && document.ok == 1) {\n        try {\n          var collection = new Collection(self, collectionName, self.pkFactory, options);\n        } catch(err) {\n          return callback(err, null);\n        }\n        return callback(null, collection);\n      } else {\n        err != null ? callback(err, null) : callback(self.wrap(document), null);\n      }\n    });\n  });\n};\n\n/**\n * Execute a command hash against MongoDB. This lets you acess any commands not available through the api on the server.\n *\n * @param {Object} selector the command hash to send to the server, ex: {ping:1}.\n * @param {Function} callback this will be called after executing this method. The command always return the whole result of the command as the second parameter.\n * @return {null}\n * @api public\n */\nDb.prototype.command = function(selector, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  // Set up the options\n  var cursor = new Cursor(this\n    , new Collection(this, DbCommand.SYSTEM_COMMAND_COLLECTION), selector, {}, {\n      limit: -1, timeout: QueryCommand.OPTS_NO_CURSOR_TIMEOUT, dbName: options['dbName']\n    });\n\n  // Set read preference if we set one\n  var readPreference = options['readPreference'] ? options['readPreference'] : false;\n\n  // Ensure only commands who support read Prefrences are exeuted otherwise override and use Primary\n  if(readPreference != false) {\n    if(selector['group'] || selector['aggregate'] || selector['collStats'] || selector['dbStats']\n      || selector['count'] || selector['distinct'] || selector['geoNear'] || selector['geoSearch'] || selector['geoWalk']\n      || (selector['mapreduce'] && selector.out == 'inline')) {\n      // Set the read preference\n      cursor.setReadPreference(readPreference);\n    } else {\n      cursor.setReadPreference(ReadPreference.PRIMARY);\n    }\n  }\n\n  // Return the next object\n  cursor.nextObject(callback);\n};\n\n/**\n * Drop a collection from the database, removing it permanently. New accesses will create a new collection.\n *\n * @param {String} collectionName the name of the collection we wish to drop.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from dropCollection or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.dropCollection = function(collectionName, callback) {\n  var self = this;\n\n  // Drop the collection\n  this._executeQueryCommand(DbCommand.createDropCollectionCommand(this, collectionName), function(err, result) {\n    if(err == null && result.documents[0].ok == 1) {\n      if(callback != null) return callback(null, true);\n    } else {\n      if(callback != null) err != null ? callback(err, null) : callback(self.wrap(result.documents[0]), null);\n    }\n  });\n};\n\n/**\n * Rename a collection.\n *\n * @param {String} fromCollection the name of the current collection we wish to rename.\n * @param {String} toCollection the new name of the collection.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from renameCollection or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.renameCollection = function(fromCollection, toCollection, callback) {\n  var self = this;\n\n  // Execute the command, return the new renamed collection if successful\n  this._executeQueryCommand(DbCommand.createRenameCollectionCommand(this, fromCollection, toCollection), function(err, result) {\n    if(err == null && result.documents[0].ok == 1) {\n      if(callback != null) return callback(null, new Collection(self, toCollection, self.pkFactory));\n    } else {\n      if(callback != null) err != null ? callback(err, null) : callback(self.wrap(result.documents[0]), null);\n    }\n  });\n};\n\n/**\n * Return last error message for the given connection, note options can be combined.\n *\n * Options\n *  - **fsync** {Boolean, default:false}, option forces the database to fsync all files before returning.\n *  - **j** {Boolean, default:false}, awaits the journal commit before returning, > MongoDB 2.0.\n *  - **w** {Number}, until a write operation has been replicated to N servers.\n *  - **wtimeout** {Number}, number of miliseconds to wait before timing out.\n *\n * Connection Options\n *  - **connection** {Connection}, fire the getLastError down a specific connection.\n *\n * @param {Object} [options] returns option results.\n * @param {Object} [connectionOptions] returns option results.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from lastError or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.lastError = function(options, connectionOptions, callback) {\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n  connectionOptions = args.length ? args.shift() : {};\n\n  this._executeQueryCommand(DbCommand.createGetLastErrorCommand(options, this), connectionOptions, function(err, error) {\n    callback(err, error && error.documents);\n  });\n};\n\n/**\n * Legacy method calls.\n *\n * @ignore\n * @api private\n */\nDb.prototype.error = Db.prototype.lastError;\nDb.prototype.lastStatus = Db.prototype.lastError;\n\n/**\n * Return all errors up to the last time db reset_error_history was called.\n *\n * Options\n *  - **connection** {Connection}, fire the getLastError down a specific connection.\n *\n * @param {Object} [options] returns option results.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from previousErrors or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.previousErrors = function(options, callback) {\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  this._executeQueryCommand(DbCommand.createGetPreviousErrorsCommand(this), options, function(err, error) {\n    callback(err, error.documents);\n  });\n};\n\n/**\n * Runs a command on the database.\n * @ignore\n * @api private\n */\nDb.prototype.executeDbCommand = function(command_hash, options, callback) {\n  if(callback == null) { callback = options; options = {}; }\n  this._executeQueryCommand(DbCommand.createDbSlaveOkCommand(this, command_hash, options), options, callback);\n};\n\n/**\n * Runs a command on the database as admin.\n * @ignore\n * @api private\n */\nDb.prototype.executeDbAdminCommand = function(command_hash, options, callback) {\n  if(callback == null) { callback = options; options = {}; }\n  this._executeQueryCommand(DbCommand.createAdminDbCommand(this, command_hash), options, callback);\n};\n\n/**\n * Resets the error history of the mongo instance.\n *\n * Options\n *  - **connection** {Connection}, fire the getLastError down a specific connection.\n *\n * @param {Object} [options] returns option results.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from resetErrorHistory or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.resetErrorHistory = function(options, callback) {\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  this._executeQueryCommand(DbCommand.createResetErrorHistoryCommand(this), options, function(err, error) {\n    callback(err, error.documents);\n  });\n};\n\n/**\n * Creates an index on the collection.\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **unique** {Boolean, default:false}, creates an unique index.\n *  - **sparse** {Boolean, default:false}, creates a sparse index.\n *  - **background** {Boolean, default:false}, creates the index in the background, yielding whenever possible.\n *  - **dropDups** {Boolean, default:false}, a unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n *  - **min** {Number}, for geospatial indexes set the lower bound for the co-ordinates.\n *  - **max** {Number}, for geospatial indexes set the high bound for the co-ordinates.\n *  - **v** {Number}, specify the format version of the indexes.\n *  - **expireAfterSeconds** {Number}, allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n *  - **name** {String}, override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n *\n * @param {String} collectionName name of the collection to create the index on.\n * @param {Object} fieldOrSpec fieldOrSpec that defines the index.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from createIndex or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.createIndex = function(collectionName, fieldOrSpec, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n  options = typeof callback === 'function' ? options : callback;\n  options = options == null ? {} : options;\n\n  // Get the error options\n  var errorOptions = _getWriteConcern(this, options, callback);\n  // Create command\n  var command = DbCommand.createCreateIndexCommand(this, collectionName, fieldOrSpec, options);\n  // Default command options\n  var commandOptions = {};\n\n  // If we have error conditions set handle them\n  if(_hasWriteConcern(errorOptions) && typeof callback == 'function') {\n    // Insert options\n    commandOptions['read'] = false;\n    // If we have safe set set async to false\n    if(errorOptions == null) commandOptions['async'] = true;\n\n    // Set safe option\n    commandOptions['safe'] = errorOptions;\n    // If we have an error option\n    if(typeof errorOptions == 'object') {\n      var keys = Object.keys(errorOptions);\n      for(var i = 0; i < keys.length; i++) {\n        commandOptions[keys[i]] = errorOptions[keys[i]];\n      }\n    }\n\n    // Execute insert command\n    this._executeInsertCommand(command, commandOptions, function(err, result) {\n      if(err != null) return callback(err, null);\n\n      result = result && result.documents;\n      if (result[0].err) {\n        callback(self.wrap(result[0]));\n      } else {\n        callback(null, command.documents[0].name);\n      }\n    });\n  } else if(_hasWriteConcern(errorOptions) && callback == null) {\n    throw new Error(\"Cannot use a writeConcern without a provided callback\");\n  } else {\n    // Execute insert command\n    var result = this._executeInsertCommand(command, commandOptions);\n    // If no callback just return\n    if(!callback) return;\n    // If error return error\n    if(result instanceof Error) {\n      return callback(result);\n    }\n    // Otherwise just return\n    return callback(null, null);\n  }\n};\n\n/**\n * Ensures that an index exists, if it does not it creates it\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **unique** {Boolean, default:false}, creates an unique index.\n *  - **sparse** {Boolean, default:false}, creates a sparse index.\n *  - **background** {Boolean, default:false}, creates the index in the background, yielding whenever possible.\n *  - **dropDups** {Boolean, default:false}, a unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n *  - **min** {Number}, for geospatial indexes set the lower bound for the co-ordinates.\n *  - **max** {Number}, for geospatial indexes set the high bound for the co-ordinates.\n *  - **v** {Number}, specify the format version of the indexes.\n *  - **expireAfterSeconds** {Number}, allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n *  - **name** {String}, override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {String} collectionName name of the collection to create the index on.\n * @param {Object} fieldOrSpec fieldOrSpec that defines the index.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from ensureIndex or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.ensureIndex = function(collectionName, fieldOrSpec, options, callback) {\n  var self = this;\n\n  if (typeof callback === 'undefined' && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (options == null) {\n    options = {};\n  }\n\n  // Get the error options\n  var errorOptions = _getWriteConcern(this, options, callback);\n  // Make sure we don't try to do a write concern without a callback\n  if(_hasWriteConcern(errorOptions) && callback == null)\n    throw new Error(\"Cannot use a writeConcern without a provided callback\");\n  // Create command\n  var command = DbCommand.createCreateIndexCommand(this, collectionName, fieldOrSpec, options);\n  var index_name = command.documents[0].name;\n\n  // Default command options\n  var commandOptions = {};\n  // Check if the index allready exists\n  this.indexInformation(collectionName, function(err, collectionInfo) {\n    if(err != null) return callback(err, null);\n\n    if(!collectionInfo[index_name])  {\n      // If we have error conditions set handle them\n      if(_hasWriteConcern(errorOptions) && typeof callback == 'function') {\n        // Insert options\n        commandOptions['read'] = false;\n        // If we have safe set set async to false\n        if(errorOptions == null) commandOptions['async'] = true;\n\n        // If we have an error option\n        if(typeof errorOptions == 'object') {\n          var keys = Object.keys(errorOptions);\n          for(var i = 0; i < keys.length; i++) {\n            commandOptions[keys[i]] = errorOptions[keys[i]];\n          }\n        }\n\n        if(typeof callback === 'function' \n          && commandOptions.w < 1 && !commandOptions.fsync && !commandOptions.journal) {\n          commandOptions.w = 1;\n        }\n\n        self._executeInsertCommand(command, commandOptions, function(err, result) {\n          // Only callback if we have one specified\n          if(typeof callback === 'function') {\n            if(err != null) return callback(err, null);\n\n            result = result && result.documents;\n            if (result[0].err) {\n              callback(self.wrap(result[0]));\n            } else {\n              callback(null, command.documents[0].name);\n            }\n          }\n        });\n      } else {\n        // Execute insert command\n        var result = self._executeInsertCommand(command, commandOptions);\n        // If no callback just return\n        if(!callback) return;\n        // If error return error\n        if(result instanceof Error) {\n          return callback(result);\n        }\n        // Otherwise just return\n        return callback(null, index_name);\n      }\n    } else {\n      if(typeof callback === 'function') return callback(null, index_name);\n    }\n  });\n};\n\n/**\n * Returns the information available on allocated cursors.\n *\n * Options\n *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n *\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from cursorInfo or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.cursorInfo = function(options, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  this._executeQueryCommand(DbCommand.createDbSlaveOkCommand(this, {'cursorInfo':1}), options, function(err, result) {\n    callback(err, result.documents[0]);\n  });\n};\n\n/**\n * Drop an index on a collection.\n *\n * @param {String} collectionName the name of the collection where the command will drop an index.\n * @param {String} indexName name of the index to drop.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from dropIndex or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.dropIndex = function(collectionName, indexName, callback) {\n  this._executeQueryCommand(DbCommand.createDropIndexCommand(this, collectionName, indexName), callback);\n};\n\n/**\n * Reindex all indexes on the collection\n * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n *\n * @param {String} collectionName the name of the collection.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from reIndex or null if an error occured.\n * @api public\n**/\nDb.prototype.reIndex = function(collectionName, callback) {\n  this._executeQueryCommand(DbCommand.createReIndexCommand(this, collectionName), function(err, result) {\n    if(err != null) {\n      callback(err, false);\n    } else if(result.documents[0].errmsg == null) {\n      callback(null, true);\n    } else {\n      callback(new Error(result.documents[0].errmsg), false);\n    }\n  });\n};\n\n/**\n * Retrieves this collections index info.\n *\n * Options\n *  - **full** {Boolean, default:false}, returns the full raw index information.\n *  - **readPreference** {String}, the preferred read preference ((Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {String} collectionName the name of the collection.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from indexInformation or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.indexInformation = function(collectionName, options, callback) {\n  if(typeof callback === 'undefined') {\n    if(typeof options === 'undefined') {\n      callback = collectionName;\n      collectionName = null;\n    } else {\n      callback = options;\n    }\n    options = {};\n  }\n\n  // If we specified full information\n  var full = options['full'] == null ? false : options['full'];\n  // Build selector for the indexes\n  var selector = collectionName != null ? {ns: (this.databaseName + \".\" + collectionName)} : {};\n\n  // Set read preference if we set one\n  var readPreference = options['readPreference'] ? options['readPreference'] : ReadPreference.PRIMARY;\n\n  // Iterate through all the fields of the index\n  this.collection(DbCommand.SYSTEM_INDEX_COLLECTION, function(err, collection) {\n    // Perform the find for the collection\n    collection.find(selector).setReadPreference(readPreference).toArray(function(err, indexes) {\n      if(err != null) return callback(err, null);\n      // Contains all the information\n      var info = {};\n\n      // if full defined just return all the indexes directly\n      if(full) return callback(null, indexes);\n\n      // Process all the indexes\n      for(var i = 0; i < indexes.length; i++) {\n        var index = indexes[i];\n        // Let's unpack the object\n        info[index.name] = [];\n        for(var name in index.key) {\n          info[index.name].push([name, index.key[name]]);\n        }\n      }\n\n      // Return all the indexes\n      callback(null, info);\n    });\n  });\n};\n\n/**\n * Drop a database.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from dropDatabase or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.dropDatabase = function(callback) {\n  var self = this;\n\n  this._executeQueryCommand(DbCommand.createDropDatabaseCommand(this), function(err, result) {\n    if (err == null && result.documents[0].ok == 1) {\n      callback(null, true);\n    } else {\n      if (err) {\n        callback(err, false);\n      } else {\n        callback(self.wrap(result.documents[0]), false);\n      }\n    }\n  });\n};\n\n/**\n * Get all the db statistics.\n *\n * Options\n *  - **scale** {Number}, divide the returned sizes by scale value.\n *  - **readPreference** {String}, the preferred read preference ((Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {Objects} [options] options for the stats command\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from stats or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.prototype.stats = function stats(options, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  // Fetch all commands\n  options = args.length ? args.shift() : {};\n\n  // Build command object\n  var commandObject = {\n    dbStats:this.collectionName,\n  }\n\n  // Check if we have the scale value\n  if(options['scale'] != null) commandObject['scale'] = options['scale'];\n\n  // Execute the command\n  this.command(commandObject, options, callback);\n}\n\n/**\n * Register a handler\n * @ignore\n * @api private\n */\nDb.prototype._registerHandler = function(db_command, raw, connection, exhaust, callback) {\n  // If we have an array of commands, chain them\n  var chained = Array.isArray(db_command);\n\n  // Check if we have exhausted\n  if(typeof exhaust == 'function') {\n    callback = exhaust;\n    exhaust = false;\n  }\n\n  // If they are chained we need to add a special handler situation\n  if(chained) {\n    // List off chained id's\n    var chainedIds = [];\n    // Add all id's\n    for(var i = 0; i < db_command.length; i++) chainedIds.push(db_command[i].getRequestId().toString());\n    // Register all the commands together\n    for(var i = 0; i < db_command.length; i++) {\n      var command = db_command[i];\n      // Add the callback to the store\n      this._callBackStore.once(command.getRequestId(), callback);\n      // Add the information about the reply\n      this._callBackStore._notReplied[command.getRequestId().toString()] = {start: new Date().getTime(), 'raw': raw, chained:chainedIds, connection:connection, exhaust:false};\n    }\n  } else {\n    // Add the callback to the list of handlers\n    this._callBackStore.once(db_command.getRequestId(), callback);\n    // Add the information about the reply\n    this._callBackStore._notReplied[db_command.getRequestId().toString()] = {start: new Date().getTime(), 'raw': raw, connection:connection, exhaust:exhaust};\n  }\n}\n\n/**\n * Re-Register a handler, on the cursor id f.ex\n * @ignore\n * @api private\n */\nDb.prototype._reRegisterHandler = function(newId, object, callback) {\n  // Add the callback to the list of handlers\n  this._callBackStore.once(newId, object.callback.listener);\n  // Add the information about the reply\n  this._callBackStore._notReplied[newId] = object.info;\n}\n\n/**\n *\n * @ignore\n * @api private\n */\nDb.prototype._callHandler = function(id, document, err) {\n  // If there is a callback peform it\n  if(this._callBackStore.listeners(id).length >= 1) {\n    // Get info object\n    var info = this._callBackStore._notReplied[id];\n    // Delete the current object\n    delete this._callBackStore._notReplied[id];\n    // Emit to the callback of the object\n    this._callBackStore.emit(id, err, document, info.connection);\n  }\n}\n\n/**\n *\n * @ignore\n * @api private\n */\nDb.prototype._hasHandler = function(id) {\n  // If there is a callback peform it\n  return this._callBackStore.listeners(id).length >= 1;\n}\n\n/**\n *\n * @ignore\n * @api private\n */\nDb.prototype._removeHandler = function(id) {\n  // Remove the information\n  if(this._callBackStore._notReplied[id] != null) delete this._callBackStore._notReplied[id];\n  // Remove the callback if it's registered\n  this._callBackStore.removeAllListeners(id);\n  // Force cleanup _events, node.js seems to set it as a null value\n  if(this._callBackStore._events != null) delete this._callBackStore._events[id];\n}\n\n/**\n *\n * @ignore\n * @api private\n */\nDb.prototype._findHandler = function(id) {\n  var info = this._callBackStore._notReplied[id];\n  // Return the callback\n  return {info:info, callback:(this._callBackStore.listeners(id).length >= 1) ? this._callBackStore.listeners(id)[0] : null}\n}\n\n/**\n * @ignore\n */\nvar __executeQueryCommand = function(self, db_command, options, callback) {\n  // Options unpacking\n  var read = options['read'] != null ? options['read'] : false;\n  var raw = options['raw'] != null ? options['raw'] : self.raw;\n  var onAll = options['onAll'] != null ? options['onAll'] : false;\n  var specifiedConnection = options['connection'] != null ? options['connection'] : null;\n\n  // Correct read preference to default primary if set to false, null or primary\n  if(!(typeof read == 'object') && read._type == 'ReadPreference') {\n    read = (read == null || read == 'primary' || read == false) ? ReadPreference.PRIMARY : read;\n    if(!ReadPreference.isValid(read)) return callback(new Error(\"Illegal readPreference mode specified, \" + read));\n  } else if(typeof read == 'object' && read._type == 'ReadPreference') {\n    if(!read.isValid()) return callback(new Error(\"Illegal readPreference mode specified, \" + read.mode));\n  }\n\n  // If we have a read preference set and we are a mongos pass the read preference on to the mongos instance,\n  if(self.serverConfig.isMongos() && read != null && read != false) {\n    db_command.setMongosReadPreference(read);\n  }\n\n  // If we got a callback object\n  if(typeof callback === 'function' && !onAll) {\n    // Override connection if we passed in a specific connection\n    var connection = specifiedConnection != null ? specifiedConnection : null;\n    // connection = connection != null && connection.connected != null ? connection : null;\n\n    if(connection instanceof Error) return callback(connection, null);\n\n    // Fetch either a reader or writer dependent on the specified read option if no connection\n    // was passed in\n    if(connection == null) {\n      connection = read == null || read == 'primary' || read == false ? self.serverConfig.checkoutWriter(true) : self.serverConfig.checkoutReader(read);\n    }\n\n    // Ensure we have a valid connection\n    if(connection == null) {\n      return callback(new Error(\"no open connections\"));\n    } else if(connection instanceof Error || connection['message'] != null) {\n      return callback(connection);\n    }\n\n    // Exhaust Option\n    var exhaust = options.exhaust || false;\n\n    // Register the handler in the data structure\n    self._registerHandler(db_command, raw, connection, exhaust, callback);\n\n    // Write the message out and handle any errors if there are any\n    connection.write(db_command, function(err) {\n      if(err != null) {\n        // Call the handler with an error\n        self._callHandler(db_command.getRequestId(), null, err);\n      }\n    });\n  } else if(typeof callback === 'function' && onAll) {\n    var connections = self.serverConfig.allRawConnections();\n    var numberOfEntries = connections.length;\n    // Go through all the connections\n    for(var i = 0; i < connections.length; i++) {\n      // Fetch a connection\n      var connection = connections[i];\n      // Override connection if needed\n      connection = specifiedConnection != null ? specifiedConnection : connection;\n      // Ensure we have a valid connection\n      if(connection == null) {\n        return callback(new Error(\"no open connections\"));\n      } else if(connection instanceof Error) {\n        return callback(connection);\n      }\n\n      // Register the handler in the data structure\n      self._registerHandler(db_command, raw, connection, callback);\n\n      // Write the message out\n      connection.write(db_command, function(err) {\n        // Adjust the number of entries we need to process\n        numberOfEntries = numberOfEntries - 1;\n        // Remove listener\n        if(err != null) {\n          // Clean up listener and return error\n          self._removeHandler(db_command.getRequestId());\n        }\n\n        // No more entries to process callback with the error\n        if(numberOfEntries <= 0) {\n          callback(err);\n        }\n      });\n\n      // Update the db_command request id\n      db_command.updateRequestId();\n    }\n  } else {\n    // Fetch either a reader or writer dependent on the specified read option\n    var connection = read == null || read == 'primary' || read == false ? self.serverConfig.checkoutWriter(true) : self.serverConfig.checkoutReader(read);\n    // Override connection if needed\n    connection = specifiedConnection != null ? specifiedConnection : connection;\n    // Ensure we have a valid connection\n    if(connection == null || connection instanceof Error || connection['message'] != null) return null;\n    // Write the message out\n    connection.write(db_command, function(err) {\n      if(err != null) {\n        // Emit the error\n        self.emit(\"error\", err);\n      }\n    });\n  }\n}\n\n/**\n * @ignore\n */\nvar __retryCommandOnFailure = function(self, retryInMilliseconds, numberOfTimes, command, db_command, options, callback) {\n  if(this._state == 'connected' || this._state == 'disconnected') this._state = 'connecting';\n  // Number of retries done\n  var numberOfRetriesDone = numberOfTimes;\n  // Retry function, execute once\n  var retryFunction = function(_self, _numberOfRetriesDone, _retryInMilliseconds, _numberOfTimes, _command, _db_command, _options, _callback) {\n    _self.serverConfig.connect(_self, {}, function(err, result, _serverConfig) {\n      // Adjust the number of retries left\n      _numberOfRetriesDone = _numberOfRetriesDone - 1;\n      // Definitively restart\n      if(err != null && _numberOfRetriesDone > 0) {\n        _self._state = 'connecting';\n        // Close the server config\n        _serverConfig.close(function(err) {\n          // Retry the connect\n          setTimeout(function() {\n            retryFunction(_self, _numberOfRetriesDone, _retryInMilliseconds, _numberOfTimes, _command, _db_command, _options, _callback);\n          }, _retryInMilliseconds);\n        });\n      } else if(err != null && _numberOfRetriesDone <= 0) {\n        _self._state = 'disconnected';\n        // Force close the current connections\n        _serverConfig.close(function(_err) {\n          // Force close the current connections\n          if(typeof _callback == 'function') _callback(err, null);\n        });\n      } else if(err == null && _self.serverConfig.isConnected() == true && Array.isArray(_self.auths) && _self.auths.length > 0) {\n        _self._state = 'connected';\n        // Get number of auths we need to execute\n        var numberOfAuths = _self.auths.length;\n        // Apply all auths\n        for(var i = 0; i < _self.auths.length; i++) {\n          _self.authenticate(_self.auths[i].username, _self.auths[i].password, {'authdb':_self.auths[i].authdb}, function(err, authenticated) {\n            numberOfAuths = numberOfAuths - 1;\n\n            // If we have no more authentications to replay\n            if(numberOfAuths == 0) {\n              if(err != null || !authenticated) {\n                if(typeof _callback == 'function') _callback(err, null);\n                return;\n              } else {\n                // Execute command\n                command(_self, _db_command, _options, _callback);\n\n                // Execute any backed up commands\n                process.nextTick(function() {\n                  // Execute any backed up commands\n                  while(_self.commands.length > 0) {\n                    // Fetch the command\n                    var command = _self.commands.shift();\n                    // Execute based on type\n                    if(command['type'] == 'query') {\n                      __executeQueryCommand(_self, command['db_command'], command['options'], command['callback']);\n                    } else if(command['type'] == 'insert') {\n                      __executeInsertCommand(_self, command['db_command'], command['options'], command['callback']);\n                    }\n                  }\n                });\n              }\n            }\n          });\n        }\n      } else if(err == null && _self.serverConfig.isConnected() == true) {\n        _self._state = 'connected';\n        // Execute command\n        command(_self, _db_command, _options, _callback);\n\n        process.nextTick(function() {\n          // Execute any backed up commands\n          while(_self.commands.length > 0) {\n            // Fetch the command\n            var command = _self.commands.shift();\n            // Execute based on type\n            if(command['type'] == 'query') {\n              __executeQueryCommand(_self, command['db_command'], command['options'], command['callback']);\n            } else if(command['type'] == 'insert') {\n              __executeInsertCommand(_self, command['db_command'], command['options'], command['callback']);\n            }\n          }\n        });\n      } else {\n        _self._state = 'connecting';\n        // Force close the current connections\n        _serverConfig.close(function(err) {\n        // _self.serverConfig.close(function(err) {\n          // Retry the connect\n          setTimeout(function() {\n            retryFunction(_self, _numberOfRetriesDone, _retryInMilliseconds, _numberOfTimes, _command, _db_command, _options, _callback);\n          }, _retryInMilliseconds);\n        });\n      }\n    });\n  };\n\n  // Execute function first time\n  retryFunction(self, numberOfRetriesDone, retryInMilliseconds, numberOfTimes, command, db_command, options, callback);\n}\n\n/**\n * Execute db query command (not safe)\n * @ignore\n * @api private\n */\nDb.prototype._executeQueryCommand = function(db_command, options, callback) {\n  var self = this;\n\n  // Unpack the parameters\n  if (typeof callback === 'undefined') {\n    callback = options;\n    options = {};\n  }\n\n  // fast fail option used for HA, no retry\n  var failFast = options['failFast'] != null\n    ? options['failFast']\n    : false;\n\n  // Check if the user force closed the command\n  if(this._applicationClosed) {\n    var err = new Error(\"db closed by application\");\n    if('function' == typeof callback) {\n      return callback(err, null);\n    } else {\n      throw err;\n    }\n  }\n\n  var config = this.serverConfig;\n  // If the pool is not connected, attemp to reconnect to send the message\n  if(this._state == 'connecting' && config.autoReconnect && !failFast) {\n    return process.nextTick(function() {\n      self.commands.push({\n        type: 'query',\n        db_command: db_command,\n        options: options,\n        callback: callback\n      });\n    })\n  }\n\n  if(!failFast && !config.isConnected() && config.autoReconnect \n      && (options.read == null \n        || options.read == false\n        || options.read == ReadPreference.PRIMARY \n        || config.checkoutReader() == null)) {\n    this._state = 'connecting';\n    return __retryCommandOnFailure(this,\n                                   this.retryMiliSeconds,\n                                   this.numberOfRetries,\n                                   __executeQueryCommand,\n                                   db_command,\n                                   options,\n                                   callback);\n  }\n\n  if(!config.isConnected() && !config.autoReconnect && callback) {\n    // Fire an error to the callback if we are not connected\n    // and don't reconnect.\n    return callback(new Error(\"no open connections\"), null);\n  }\n\n  __executeQueryCommand(self, db_command, options, function (err, result, conn) {\n    callback(err, result, conn);\n  });\n\n};\n\n/**\n * @ignore\n */\nvar __executeInsertCommand = function(self, db_command, options, callback) {\n  // Always checkout a writer for this kind of operations\n  var connection = self.serverConfig.checkoutWriter();\n  // Get safe mode\n  var safe = options['safe'] != null ? options['safe'] : false;\n  var raw = options['raw'] != null ? options['raw'] : self.raw;\n  var specifiedConnection = options['connection'] != null ? options['connection'] : null;\n  // Override connection if needed\n  connection = specifiedConnection != null ? specifiedConnection : connection;\n\n  // Ensure we have a valid connection\n  if(typeof callback === 'function') {\n    // Ensure we have a valid connection\n    if(connection == null) {\n      return callback(new Error(\"no open connections\"));\n    } else if(connection instanceof Error) {\n      return callback(connection);\n    }\n\n    var errorOptions = _getWriteConcern(self, options, callback);\n    if(errorOptions.w > 0 || errorOptions.w == 'majority' || errorOptions.j || errorOptions.journal || errorOptions.fsync) {      \n      // db command is now an array of commands (original command + lastError)\n      db_command = [db_command, DbCommand.createGetLastErrorCommand(safe, self)];\n      // Register the handler in the data structure\n      self._registerHandler(db_command[1], raw, connection, callback);      \n    }\n  }\n\n  // If we have no callback and there is no connection\n  if(connection == null) return null;\n  if(connection instanceof Error && typeof callback == 'function') return callback(connection, null);\n  if(connection instanceof Error) return null;\n  if(connection == null && typeof callback == 'function') return callback(new Error(\"no primary server found\"), null);\n\n  // Write the message out\n  connection.write(db_command, function(err) {    \n    // Return the callback if it's not a safe operation and the callback is defined\n    if(typeof callback === 'function' && (safe == null || safe == false)) {\n      // Perform the callback\n      callback(err, null);\n    } else if(typeof callback === 'function') {\n      // Call the handler with an error\n      self._callHandler(db_command[1].getRequestId(), null, err);\n    } else if(typeof callback == 'function' && safe && safe.w == -1) {\n      // Call the handler with no error\n      self._callHandler(db_command[1].getRequestId(), null, null);\n    } else if(!safe && safe.w == -1) {\n      self.emit(\"error\", err);\n    }\n  });\n}\n\n/**\n * Execute an insert Command\n * @ignore\n * @api private\n */\nDb.prototype._executeInsertCommand = function(db_command, options, callback) {\n  var self = this;\n\n  // Unpack the parameters\n  if(callback == null && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  // Ensure options are not null\n  options = options == null ? {} : options;\n\n  // Check if the user force closed the command\n  if(this._applicationClosed) {\n    if(typeof callback == 'function') {\n      return callback(new Error(\"db closed by application\"), null);\n    } else {\n      throw new Error(\"db closed by application\");\n    }\n  }\n\n  // If the pool is not connected, attemp to reconnect to send the message\n  if(self._state == 'connecting' && this.serverConfig.autoReconnect) {\n    process.nextTick(function() {\n      self.commands.push({type:'insert', 'db_command':db_command, 'options':options, 'callback':callback});\n    })\n  } else if(!this.serverConfig.isConnected() && this.serverConfig.autoReconnect) {\n    this._state = 'connecting';\n    // Retry command\n    __retryCommandOnFailure(this, this.retryMiliSeconds, this.numberOfRetries, __executeInsertCommand, db_command, options, callback);\n  } else if(!this.serverConfig.isConnected() && !this.serverConfig.autoReconnect && callback) {\n    // Fire an error to the callback if we are not connected and don't do reconnect\n    if(callback) callback(new Error(\"no open connections\"), null);\n  } else {\n    __executeInsertCommand(self, db_command, options, callback);\n  }\n}\n\n/**\n * Update command is the same\n * @ignore\n * @api private\n */\nDb.prototype._executeUpdateCommand = Db.prototype._executeInsertCommand;\n/**\n * Remove command is the same\n * @ignore\n * @api private\n */\nDb.prototype._executeRemoveCommand = Db.prototype._executeInsertCommand;\n\n/**\n * Wrap a Mongo error document into an Error instance\n * @ignore\n * @api private\n */\nDb.prototype.wrap = function(error) {\n  var msg = error.err || error.errmsg || error;\n  var e = new Error(msg);\n  e.name = 'MongoError';\n\n  // Get all object keys\n  var keys = Object.keys(error);\n  // Populate error object with properties\n  for(var i = 0; i < keys.length; i++) {\n    e[keys[i]] = error[keys[i]];\n  }\n\n  return e;\n}\n\n/**\n * Default URL\n *\n * @classconstant DEFAULT_URL\n **/\nDb.DEFAULT_URL = 'mongodb://localhost:27017/default';\n\n/**\n * Connect to MongoDB using a url as documented at\n *\n *  www.mongodb.org/display/DOCS/Connections\n *\n * Options\n *  - **uri_decode_auth** {Boolean, default:false} uri decode the user name and password for authentication\n *  - **db** {Object, default: null} a hash off options to set on the db object, see **Db constructor**\n *  - **server** {Object, default: null} a hash off options to set on the server objects, see **Server** constructor**\n *  - **replSet** {Object, default: null} a hash off options to set on the replSet object, see **ReplSet** constructor**\n *  - **mongos** {Object, default: null} a hash off options to set on the mongos object, see **Mongos** constructor**\n *\n * @param {String} url connection url for MongoDB.\n * @param {Object} [options] optional options for insert command\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the db instance or null if an error occured.\n * @return {null}\n * @api public\n */\nDb.connect = function(url, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] == 'function' ? args.pop() : null;\n  options = args.length ? args.shift() : null;\n  options = options || {};\n  var serverOptions = options.server || {};\n  var mongosOptions = options.mongos || {};\n  var replSetServersOptions = options.replSet || options.replSetServers || {};\n  var dbOptions = options.db || {};\n\n  // If callback is null throw an exception\n  if(callback == null) throw new Error(\"no callback function provided\");\n\n  // Parse the string\n  var object = parse(url);\n  // Merge in any options for db in options object\n  if(dbOptions) {\n    for(var name in dbOptions) object.db_options[name] = dbOptions[name];\n  }\n\n  // Merge in any options for server in options object\n  if(serverOptions) {\n    for(var name in serverOptions) object.server_options[name] = serverOptions[name];\n  }\n\n  // Merge in any replicaset server options\n  if(replSetServersOptions) {\n    for(var name in replSetServersOptions) object.rs_options[name] = replSetServersOptions[name];    \n  }\n\n  // Merge in any replicaset server options\n  if(mongosOptions) {\n    for(var name in mongosOptions) object.mongos_options[name] = mongosOptions[name];    \n  }\n\n  // We need to ensure that the list of servers are only either direct members or mongos\n  // they cannot be a mix of monogs and mongod's\n  var totalNumberOfServers = object.servers.length;\n  var totalNumberOfMongosServers = 0;\n  var totalNumberOfMongodServers = 0;\n  var serverConfig = null;\n\n  // Failure modes\n  if(object.servers.length == 0) throw new Error(\"connection string must contain at least one seed host\");\n\n  // If we have no db setting for the native parser try to set the c++ one first\n  object.db_options.native_parser = _setNativeParser(object.db_options);\n  // If no auto_reconnect is set, set it to true as default for single servers\n  if(typeof object.server_options.auto_reconnect != 'boolean') {\n    object.server_options.auto_reconnect = true;\n  }\n\n  // If we have more than a server, it could be replicaset or mongos list\n  // need to verify that it's one or the other and fail if it's a mix\n  // Connect to all servers and run ismaster\n  for(var i = 0; i < object.servers.length; i++) {\n    // Set up the Server object\n    var _server = object.servers[i].domain_socket \n        ? new Server(object.servers[i].domain_socket, {socketOptions:{connectTimeoutMS:1000}, auto_reconnect:false})\n        : new Server(object.servers[i].host, object.servers[i].port, {socketOptions:{connectTimeoutMS:1000}, auto_reconnect:false});\n\n    // Attempt connect\n    new Db(object.dbName, _server, {safe:false, native_parser:false}).open(function(err, db) {\n        // Update number of servers\n        totalNumberOfServers = totalNumberOfServers - 1;          \n        // If no error do the correct checks\n        if(!err) {\n          // Close the connection\n          db.close(true);\n          var isMasterDoc = db.serverConfig.isMasterDoc;\n          // Check what type of server we have\n          if(isMasterDoc.setName) totalNumberOfMongodServers++;\n          if(isMasterDoc.msg && isMasterDoc.msg == \"isdbgrid\") totalNumberOfMongosServers++;\n        }\n\n        if(totalNumberOfServers == 0) {\n          // If we have a mix of mongod and mongos, throw an error\n          if(totalNumberOfMongosServers > 0 && totalNumberOfMongodServers > 0)\n            return callback(new Error(\"cannot combine a list of replicaset seeds and mongos seeds\"));\n          \n          if(totalNumberOfMongodServers == 0 && object.servers.length == 1) {\n            var obj = object.servers[0];\n            serverConfig = obj.domain_socket ? \n                new Server(obj.domain_socket, object.server_options)\n              : new Server(obj.host, obj.port, object.server_options);            \n          } else if(totalNumberOfMongodServers > 0) {\n            serverConfig = new ReplSet(object.servers.map(function(serverObj) {\n                return new Server(serverObj.host, serverObj.port, object.server_options);\n              }), object.rs_options);\n          } else if(totalNumberOfMongosServers > 0) {\n            serverConfig = new Mongos(object.servers.map(function(serverObj) {\n                return new Server(serverObj.host, serverObj.port, object.server_options);\n              }), object.mongos_options);         \n          }\n\n          // Set up all options etc and connect to the database\n          _finishConnecting(serverConfig, object, options, callback)\n        }\n      });\n  }    \n}\n\nvar _setNativeParser = function(db_options) {\n  if(typeof db_options.native_parser == 'boolean') return db_options.native_parser;\n\n  try {\n    require('bson').BSONNative.BSON;\n    return true;\n  } catch(err) {\n    return false;\n  }\n}\n\nvar _finishConnecting = function(serverConfig, object, options, callback) {\n  // Safe settings\n  var safe = {};\n  // Build the safe parameter if needed\n  if(object.db_options.journal) safe.j = object.db_options.journal;\n  if(object.db_options.w) safe.w = object.db_options.w;\n  if(object.db_options.fsync) safe.fsync = object.db_options.fsync;\n  if(object.db_options.wtimeoutMS) safe.wtimeout = object.db_options.wtimeoutMS;\n\n  // If we have a read Preference set\n  if(object.db_options.read_preference) {\n    var readPreference = new ReadPreference(object.db_options.read_preference);\n    // If we have the tags set up\n    if(object.db_options.read_preference_tags)\n      readPreference = new ReadPreference(object.db_options.read_preference, object.db_options.read_preference_tags);\n    // Add the read preference\n    object.db_options.readPreference = readPreference;\n  }\n\n  // No safe mode if no keys\n  if(Object.keys(safe).length == 0) safe = false;\n  // Add the safe object\n  object.db_options.safe = safe;\n  // Set up the db options\n  var db = new Db(object.dbName, serverConfig, object.db_options);  \n  // Don't open the connection\n  if(options.noOpen) return db;\n\n  // Open the db\n  db.open(function(err, db){\n    if(err == null && object.auth){\n      db.authenticate(object.auth.user, object.auth.password, function(err, success){\n        if(success){\n          callback(null, db);\n        } else {\n          callback(err ? err : new Error('Could not authenticate user ' + auth[0]), db);\n        }\n      });\n    } else {\n      callback(err, db);\n    }\n  });\n}\n\n/**\n * State of the db connection\n * @ignore\n */\nObject.defineProperty(Db.prototype, \"state\", { enumerable: true\n  , get: function () {\n      return this.serverConfig._serverState;\n    }\n});\n\n/**\n * @ignore\n */\nvar _hasWriteConcern = function(errorOptions) {\n  return errorOptions == true\n    || errorOptions.w > 0\n    || errorOptions.w == 'majority'\n    || errorOptions.j == true\n    || errorOptions.journal == true\n    || errorOptions.fsync == true\n}\n\n/**\n * @ignore\n */\nvar _setWriteConcernHash = function(options) {\n  var finalOptions = {};\n  if(options.w != null) finalOptions.w = options.w;  \n  if(options.journal == true) finalOptions.j = options.journal;\n  if(options.j == true) finalOptions.j = options.j;\n  if(options.fsync == true) finalOptions.fsync = options.fsync;\n  if(options.wtimeout != null) finalOptions.wtimeout = options.wtimeout;  \n  return finalOptions;\n}\n\n/**\n * @ignore\n */\nvar _getWriteConcern = function(self, options, callback) {\n  // Final options\n  var finalOptions = {w:1};\n  // Local options verification\n  if(options.w != null || typeof options.j == 'boolean' || typeof options.journal == 'boolean' || typeof options.fsync == 'boolean') {\n    finalOptions = _setWriteConcernHash(options);\n  } else if(options.safe != null && typeof options.safe == 'object') {\n    finalOptions = _setWriteConcernHash(options.safe);\n  } else if(typeof options.safe == \"boolean\") {\n    finalOptions = {w: (options.safe ? 1 : 0)};\n  } else if(self.options.w != null || typeof self.options.j == 'boolean' || typeof self.options.journal == 'boolean' || typeof self.options.fsync == 'boolean') {\n    finalOptions = _setWriteConcernHash(self.options);\n  } else if(self.safe.w != null || typeof self.safe.j == 'boolean' || typeof self.safe.journal == 'boolean' || typeof self.safe.fsync == 'boolean') {\n    finalOptions = _setWriteConcernHash(self.safe);\n  } else if(typeof self.safe == \"boolean\") {\n    finalOptions = {w: (self.safe ? 1 : 0)};\n  }\n\n  // Ensure we don't have an invalid combination of write concerns\n  if(finalOptions.w < 1 \n    && (finalOptions.journal == true || finalOptions.j == true || finalOptions.fsync == true)) throw new Error(\"No acknowlegement using w < 1 cannot be combined with journal:true or fsync:true\");\n\n  // Return the options\n  return finalOptions;\n}\n\n/**\n * Legacy support\n *\n * @ignore\n * @api private\n */\nexports.connect = Db.connect;\nexports.Db = Db;\n\n/**\n * Remove all listeners to the db instance.\n * @ignore\n * @api private\n */\nDb.prototype.removeAllEventListeners = function() {\n  this.removeAllListeners(\"close\");\n  this.removeAllListeners(\"error\");\n  this.removeAllListeners(\"timeout\");\n  this.removeAllListeners(\"parseError\");\n  this.removeAllListeners(\"poolReady\");\n  this.removeAllListeners(\"message\");\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":91573}]],"length":91573}
