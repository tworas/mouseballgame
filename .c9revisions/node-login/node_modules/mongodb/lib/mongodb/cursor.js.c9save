{"ts":1354675587945,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var QueryCommand = require('./commands/query_command').QueryCommand,\n  GetMoreCommand = require('./commands/get_more_command').GetMoreCommand,\n  KillCursorCommand = require('./commands/kill_cursor_command').KillCursorCommand,\n  Long = require('bson').Long,\n  ReadPreference = require('./connection/read_preference').ReadPreference,\n  CursorStream = require('./cursorstream'),\n  utils = require('./utils');\n\n/**\n * Constructor for a cursor object that handles all the operations on query result\n * using find. This cursor object is unidirectional and cannot traverse backwards. Clients should not be creating a cursor directly,\n * but use find to acquire a cursor.\n *\n * Options\n *  - **skip** {Number} skip number of documents to skip.\n *  - **limit** {Number}, limit the number of results to return. -1 has a special meaning and is used by Db.eval. A value of 1 will also be treated as if it were -1.\n *  - **sort** {Array | Object}, set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.\n *  - **hint**  {Object}, hint force the query to use a specific index.\n *  - **explain** {Boolean}, explain return the explaination of the query.\n *  - **snapshot** {Boolean}, snapshot Snapshot mode assures no duplicates are returned.\n *  - **timeout** {Boolean}, timeout allow the query to timeout.\n *  - **tailable** {Boolean}, tailable allow the cursor to be tailable.\n *  - **awaitdata** {Boolean}, awaitdata allow the cursor to wait for data, only applicable for tailable cursor.\n *  - **batchSize** {Number}, batchSize the number of the subset of results to request the database to return for every request. This should initially be greater than 1 otherwise the database will automatically close the cursor. The batch size can be set to 1 with cursorInstance.batchSize after performing the initial query to the database.\n *  - **raw** {Boolean}, raw return all query documents as raw buffers (default false).\n *  - **read** {Boolean}, read specify override of read from source (primary/secondary).\n *  - **slaveOk** {Boolean}, slaveOk, sets the slaveOk flag on the query wire protocol for secondaries.\n *  - **returnKey** {Boolean}, returnKey only return the index key.\n *  - **maxScan** {Number}, maxScan limit the number of items to scan.\n *  - **min** {Number}, min set index bounds.\n *  - **max** {Number}, max set index bounds.\n *  - **showDiskLoc** {Boolean}, showDiskLoc show disk location of results.\n *  - **comment** {String}, comment you can put a $comment field on a query to make looking in the profiler logs simpler.\n *  - **numberOfRetries** {Number}, numberOfRetries if using awaidata specifies the number of times to retry on timeout.\n *  - **dbName** {String}, dbName override the default dbName.\n *  - **tailableRetryInterval** {Number}, tailableRetryInterval specify the miliseconds between getMores on tailable cursor.\n *  - **exhaust** {Boolean}, exhaust have the server send all the documents at once as getMore packets.\n *  - **partial** {Boolean}, partial have the sharded system return a partial result from mongos.\n *\n * @class Represents a Cursor.\n * @param {Db} db the database object to work with.\n * @param {Collection} collection the collection to query.\n * @param {Object} selector the query selector.\n * @param {Object} fields an object containing what fields to include or exclude from objects returned.\n * @param {Object} [options] additional options for the collection.\n*/\nfunction Cursor(db, collection, selector, fields, options) {\n  this.db = db;\n  this.collection = collection;\n  this.selector = selector;\n  this.fields = fields;\n  options = !options ? {} : options;\n\n  this.skipValue = options.skip == null ? 0 : options.skip;\n  this.limitValue = options.limit == null ? 0 : options.limit;\n  this.sortValue = options.sort;\n  this.hint = options.hint;\n  this.explainValue = options.explain;\n  this.snapshot = options.snapshot;\n  this.timeout = options.timeout == null ? true : options.timeout;\n  this.tailable = options.tailable;\n  this.awaitdata = options.awaitdata;\n  this.numberOfRetries = options.numberOfRetries == null ? 5 : options.numberOfRetries;\n  this.currentNumberOfRetries = this.numberOfRetries;\n  this.batchSizeValue = options.batchSize == null ? 0 : options.batchSize;\n  this.slaveOk = options.slaveOk == null ? collection.slaveOk : options.slaveOk;\n  this.raw = options.raw == null ? false : options.raw;\n  this.read = options.read == null ? ReadPreference.PRIMARY : options.read;\n  this.returnKey = options.returnKey;\n  this.maxScan = options.maxScan;\n  this.min = options.min;\n  this.max = options.max;\n  this.showDiskLoc = options.showDiskLoc;\n  this.comment = options.comment;\n  this.tailableRetryInterval = options.tailableRetryInterval || 100;\n  this.exhaust = options.exhaust || false;\n  this.partial = options.partial || false;\n\n  this.totalNumberOfRecords = 0;\n  this.items = [];\n  this.cursorId = Long.fromInt(0);\n\n  // This name\n  this.dbName = options.dbName;\n\n  // State variables for the cursor\n  this.state = Cursor.INIT;\n  // Keep track of the current query run\n  this.queryRun = false;\n  this.getMoreTimer = false;\n\n  // If we are using a specific db execute against it\n  if(this.dbName != null) {\n    this.collectionName = this.dbName + \".\" + this.collection.collectionName;\n  } else {\n    this.collectionName = (this.db.databaseName ? this.db.databaseName + \".\" : '') + this.collection.collectionName;\n  }\n};\n\n/**\n * Resets this cursor to its initial state. All settings like the query string,\n * tailable, batchSizeValue, skipValue and limits are preserved.\n *\n * @return {Cursor} returns itself with rewind applied.\n * @api public\n */\nCursor.prototype.rewind = function() {\n  var self = this;\n\n  if (self.state != Cursor.INIT) {\n    if (self.state != Cursor.CLOSED) {\n      self.close(function() {});\n    }\n\n    self.numberOfReturned = 0;\n    self.totalNumberOfRecords = 0;\n    self.items = [];\n    self.cursorId = Long.fromInt(0);\n    self.state = Cursor.INIT;\n    self.queryRun = false;\n  }\n\n  return self;\n};\n\n\n/**\n * Returns an array of documents. The caller is responsible for making sure that there\n * is enough memory to store the results. Note that the array only contain partial\n * results when this cursor had been previouly accessed. In that case,\n * cursor.rewind() can be used to reset the cursor.\n *\n * @param {Function} callback This will be called after executing this method successfully. The first parameter will contain the Error object if an error occured, or null otherwise. The second parameter will contain an array of BSON deserialized objects as a result of the query.\n * @return {null}\n * @api public\n */\nCursor.prototype.toArray = function(callback) {\n  var self = this;\n\n  if(!callback) {\n    throw new Error('callback is mandatory');\n  }\n\n  if(this.tailable) {\n    callback(new Error(\"Tailable cursor cannot be converted to array\"), null);\n  } else if(this.state != Cursor.CLOSED) {\n    var items = [];\n\n    this.each(function(err, item) {\n      if(err != null) return callback(err, null);\n\n      if(item != null && Array.isArray(items)) {\n        items.push(item);\n      } else {\n        var resultItems = items;\n        items = null;\n        self.items = [];\n        // Returns items\n        callback(err, resultItems);\n      }\n    });\n  } else {\n    callback(new Error(\"Cursor is closed\"), null);\n  }\n};\n\n/**\n * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,\n * not all of the elements will be iterated if this cursor had been previouly accessed.\n * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike\n * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements\n * at any given time if batch size is specified. Otherwise, the caller is responsible\n * for making sure that the entire result can fit the memory.\n *\n * @param {Function} callback this will be called for while iterating every document of the query result. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the document.\n * @return {null}\n * @api public\n */\nCursor.prototype.each = function(callback) {\n  var self = this;\n\n  if (!callback) {\n    throw new Error('callback is mandatory');\n  }\n\n  if(this.state != Cursor.CLOSED) {\n    //FIX: stack overflow (on deep callback) (cred: https://github.com/limp/node-mongodb-native/commit/27da7e4b2af02035847f262b29837a94bbbf6ce2)\n    process.nextTick(function(){\n      var s = new Date()\n      // Fetch the next object until there is no more objects\n      self.nextObject(function(err, item) {\n        if(err != null) return callback(err, null);\n        if(item != null) {\n          callback(null, item);\n          self.each(callback);\n        } else {\n          // Close the cursor if done\n          self.state = Cursor.CLOSED;\n          callback(err, null);\n        }\n      });\n    });\n  } else {\n    callback(new Error(\"Cursor is closed\"), null);\n  }\n};\n\n/**\n * Determines how many result the query for this cursor will return\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the number of results or null if an error occured.\n * @return {null}\n * @api public\n */\nCursor.prototype.count = function(callback) {\n  this.collection.count(this.selector, callback);\n};\n\n/**\n * Sets the sort parameter of this cursor to the given value.\n *\n * This method has the following method signatures:\n * (keyOrList, callback)\n * (keyOrList, direction, callback)\n *\n * @param {String|Array|Object} keyOrList This can be a string or an array. If passed as a string, the string will be the field to sort. If passed an array, each element will represent a field to be sorted and should be an array that contains the format [string, direction].\n * @param {String|Number} direction this determines how the results are sorted. \"asc\", \"ascending\" or 1 for asceding order while \"desc\", \"desceding or -1 for descending order. Note that the strings are case insensitive.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain an error object when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n * @return {Cursor} an instance of this object.\n * @api public\n */\nCursor.prototype.sort = function(keyOrList, direction, callback) {\n  callback = callback || function(){};\n  if(typeof direction === \"function\") { callback = direction; direction = null; }\n\n  if(this.tailable) {\n    callback(new Error(\"Tailable cursor doesn't support sorting\"), null);\n  } else if(this.queryRun == true || this.state == Cursor.CLOSED) {\n    callback(new Error(\"Cursor is closed\"), null);\n  } else {\n    var order = keyOrList;\n\n    if(direction != null) {\n      order = [[keyOrList, direction]];\n    }\n\n    this.sortValue = order;\n    callback(null, this);\n  }\n  return this;\n};\n\n/**\n * Sets the limit parameter of this cursor to the given value.\n *\n * @param {Number} limit the new limit.\n * @param {Function} [callback] this optional callback will be called after executing this method. The first parameter will contain an error object when the limit given is not a valid number or when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n * @return {Cursor} an instance of this object.\n * @api public\n */\nCursor.prototype.limit = function(limit, callback) {\n  if(this.tailable) {\n    if(callback) {\n      callback(new Error(\"Tailable cursor doesn't support limit\"), null);\n    } else {\n      throw new Error(\"Tailable cursor doesn't support limit\");\n    }\n  } else if(this.queryRun == true || this.state == Cursor.CLOSED) {\n    if(callback) {\n      callback(new Error(\"Cursor is closed\"), null);\n    } else {\n      throw new Error(\"Cursor is closed\");\n    }\n  } else {\n    if(limit != null && limit.constructor != Number) {\n      if(callback) {\n        callback(new Error(\"limit requires an integer\"), null);\n      } else {\n        throw new Error(\"limit requires an integer\");\n      }\n    } else {\n      this.limitValue = limit;\n      if(callback) return callback(null, this);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sets the read preference for the cursor\n *\n * @param {String} the read preference for the cursor, one of Server.READ_PRIMARY, Server.READ_SECONDARY, Server.READ_SECONDARY_ONLY\n * @param {Function} [callback] this optional callback will be called after executing this method. The first parameter will contain an error object when the read preference given is not a valid number or when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n * @return {Cursor} an instance of this object.\n * @api public\n */\nCursor.prototype.setReadPreference = function(readPreference, tags, callback) {\n  if(typeof tags == 'function') callback = tags;\n  callback = callback || function() {};\n\n  if(this.queryRun == true || this.state == Cursor.CLOSED) {\n    callback(new Error(\"Cannot change read preference on executed query or closed cursor\"));\n  } else if(readPreference == null && readPreference != 'primary'\n    && readPreference != 'secondaryOnly' && readPreference != 'secondary') {\n      callback(new Error(\"only readPreference of primary, secondary or secondaryOnly supported\"));\n  } else {\n    this.read = readPreference;\n  }\n\n  return this;\n}\n\n/**\n * Sets the skip parameter of this cursor to the given value.\n *\n * @param {Number} skip the new skip value.\n * @param {Function} [callback] this optional callback will be called after executing this method. The first parameter will contain an error object when the skip value given is not a valid number or when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n * @return {Cursor} an instance of this object.\n * @api public\n */\nCursor.prototype.skip = function(skip, callback) {\n  callback = callback || function(){};\n\n  if(this.tailable) {\n    callback(new Error(\"Tailable cursor doesn't support skip\"), null);\n  } else if(this.queryRun == true || this.state == Cursor.CLOSED) {\n    callback(new Error(\"Cursor is closed\"), null);\n  } else {\n    if(skip != null && skip.constructor != Number) {\n      callback(new Error(\"skip requires an integer\"), null);\n    } else {\n      this.skipValue = skip;\n      callback(null, this);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sets the batch size parameter of this cursor to the given value.\n *\n * @param {Number} batchSize the new batch size.\n * @param {Function} [callback] this optional callback will be called after executing this method. The first parameter will contain an error object when the batchSize given is not a valid number or when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n * @return {Cursor} an instance of this object.\n * @api public\n */\nCursor.prototype.batchSize = function(batchSize, callback) {\n  if(this.state == Cursor.CLOSED) {\n    if(callback != null) {\n      return callback(new Error(\"Cursor is closed\"), null);\n    } else {\n      throw new Error(\"Cursor is closed\");\n    }\n  } else if(batchSize != null && batchSize.constructor != Number) {\n    if(callback != null) {\n      return callback(new Error(\"batchSize requires an integer\"), null);\n    } else {\n      throw new Error(\"batchSize requires an integer\");\n    }\n  } else {\n    this.batchSizeValue = batchSize;\n    if(callback != null) return callback(null, this);\n  }\n\n  return this;\n};\n\n/**\n * The limit used for the getMore command\n *\n * @return {Number} The number of records to request per batch.\n * @ignore\n * @api private\n */\nvar limitRequest = function(self) {\n  var requestedLimit = self.limitValue;\n  var absLimitValue = Math.abs(self.limitValue);\n  var absBatchValue = Math.abs(self.batchSizeValue);\n\n  if(absLimitValue > 0) {\n    if (absBatchValue > 0) {\n      requestedLimit = Math.min(absLimitValue, absBatchValue);\n    }\n  } else {\n    requestedLimit = self.batchSizeValue;\n  }\n\n  return requestedLimit;\n};\n\n\n/**\n * Generates a QueryCommand object using the parameters of this cursor.\n *\n * @return {QueryCommand} The command object\n * @ignore\n * @api private\n */\nvar generateQueryCommand = function(self) {\n  // Unpack the options\n  var queryOptions = QueryCommand.OPTS_NONE;\n  if(!self.timeout) {\n    queryOptions |= QueryCommand.OPTS_NO_CURSOR_TIMEOUT;\n  }\n\n  if(self.tailable != null) {\n    queryOptions |= QueryCommand.OPTS_TAILABLE_CURSOR;\n    self.skipValue = self.limitValue = 0;\n\n    // if awaitdata is set\n    if(self.awaitdata != null) {\n      queryOptions |= QueryCommand.OPTS_AWAIT_DATA;\n    }\n  }\n\n  if(self.exhaust) {\n    queryOptions |= QueryCommand.OPTS_EXHAUST;\n  }\n\n  if(self.slaveOk) {\n    queryOptions |= QueryCommand.OPTS_SLAVE;\n  }\n\n  if(self.partial) {\n    queryOptions |= QueryCommand.OPTS_PARTIAL;\n  }\n\n  // limitValue of -1 is a special case used by Db#eval\n  var numberToReturn = self.limitValue == -1 ? -1 : limitRequest(self);\n\n  // Check if we need a special selector\n  if(self.sortValue != null || self.explainValue != null || self.hint != null || self.snapshot != null\n      || self.returnKey != null || self.maxScan != null || self.min != null || self.max != null\n      || self.showDiskLoc != null || self.comment != null) {\n\n    // Build special selector\n    var specialSelector = {'$query':self.selector};\n    if(self.sortValue != null) specialSelector['orderby'] = utils.formattedOrderClause(self.sortValue);\n    if(self.hint != null && self.hint.constructor == Object) specialSelector['$hint'] = self.hint;\n    if(self.snapshot != null) specialSelector['$snapshot'] = true;\n    if(self.returnKey != null) specialSelector['$returnKey'] = self.returnKey;\n    if(self.maxScan != null) specialSelector['$maxScan'] = self.maxScan;\n    if(self.min != null) specialSelector['$min'] = self.min;\n    if(self.max != null) specialSelector['$max'] = self.max;\n    if(self.showDiskLoc != null) specialSelector['$showDiskLoc'] = self.showDiskLoc;\n    if(self.comment != null) specialSelector['$comment'] = self.comment;\n    // If we have explain set only return a single document with automatic cursor close\n    if(self.explainValue != null) {\n      numberToReturn = (-1)*Math.abs(numberToReturn);\n      specialSelector['$explain'] = true;\n    }\n\n    // Return the query\n    return new QueryCommand(self.db, self.collectionName, queryOptions, self.skipValue, numberToReturn, specialSelector, self.fields);\n  } else {\n    return new QueryCommand(self.db, self.collectionName, queryOptions, self.skipValue, numberToReturn, self.selector, self.fields);\n  }\n};\n\n/**\n * @return {Object} Returns an object containing the sort value of this cursor with\n *     the proper formatting that can be used internally in this cursor.\n * @ignore\n * @api private\n */\nCursor.prototype.formattedOrderClause = function() {\n  return utils.formattedOrderClause(this.sortValue);\n};\n\n/**\n * Converts the value of the sort direction into its equivalent numerical value.\n *\n * @param sortDirection {String|number} Range of acceptable values:\n *     'ascending', 'descending', 'asc', 'desc', 1, -1\n *\n * @return {number} The equivalent numerical value\n * @throws Error if the given sortDirection is invalid\n * @ignore\n * @api private\n */\nCursor.prototype.formatSortValue = function(sortDirection) {\n  return utils.formatSortValue(sortDirection);\n};\n\n/**\n * Gets the next document from the cursor.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain an error object on error while the second parameter will contain a document from the returned result or null if there are no more results.\n * @api public\n */\nCursor.prototype.nextObject = function(callback) {\n  var self = this;\n\n  if(self.state == Cursor.INIT) {\n    var cmd;\n    try {\n      cmd = generateQueryCommand(self);\n    } catch (err) {\n      return callback(err, null);\n    }\n\n    var commandHandler = function(err, result) {\n      // console.log(\"=========================================== QUERY NEXT OBJECT\")\n      // console.dir(err)\n      if(err != null && result == null) return callback(err, null);\n\n      if(!err && result.documents[0] && result.documents[0]['$err']) {\n        return self.close(function() {callback(result.documents[0]['$err'], null);});\n      }\n\n      self.queryRun = true;\n      self.state = Cursor.OPEN; // Adjust the state of the cursor\n      self.cursorId = result.cursorId;\n      self.totalNumberOfRecords = result.numberReturned;\n\n      // Add the new documents to the list of items, using forloop to avoid\n      // new array allocations and copying\n      for(var i = 0; i < result.documents.length; i++) {\n        self.items.push(result.documents[i]);\n      }\n\n      // Ignore callbacks until the cursor is dead for exhausted\n      if(self.exhaust && result.cursorId.toString() == \"0\") {\n        self.nextObject(callback);\n      } else if(self.exhaust == false || self.exhaust == null) {\n        self.nextObject(callback);\n      }\n    };\n\n    // If we have no connection set on this cursor check one out\n    if(self.connection == null) {\n      try {\n        self.connection = this.read == null ? self.db.serverConfig.checkoutWriter() : self.db.serverConfig.checkoutReader(this.read);\n      } catch(err) {\n        return callback(err, null);\n      }\n    }\n\n    // Execute the command\n    self.db._executeQueryCommand(cmd, {exhaust: self.exhaust, raw:self.raw, read:this.read, connection:self.connection}, commandHandler);\n    // Set the command handler to null\n    commandHandler = null;\n  } else if(self.items.length) {\n    callback(null, self.items.shift());\n  } else if(self.cursorId.greaterThan(Long.fromInt(0))) {\n    getMore(self, callback);\n  } else {\n    // Force cursor to stay open\n    return self.close(function() {callback(null, null);});\n  }\n}\n\n/**\n * Gets more results from the database if any.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain an error object on error while the second parameter will contain a document from the returned result or null if there are no more results.\n * @ignore\n * @api private\n */\nvar getMore = function(self, callback) {\n  var limit = 0;\n\n  if (!self.tailable && self.limitValue > 0) {\n    limit = self.limitValue - self.totalNumberOfRecords;\n    if (limit < 1) {\n      self.close(function() {callback(null, null);});\n      return;\n    }\n  }\n  try {\n    var getMoreCommand = new GetMoreCommand(\n        self.db\n      , self.collectionName\n      , limitRequest(self)\n      , self.cursorId\n    );\n\n    // Set up options\n    var options = {read: self.read, raw: self.raw, connection:self.connection };\n\n    // Execute the command\n    self.db._executeQueryCommand(getMoreCommand, options, function(err, result) {\n      try {\n        if(err != null) {\n          return callback(err, null);\n        }\n\n        var isDead = 1 === result.responseFlag && result.cursorId.isZero();\n\n        self.cursorId = result.cursorId;\n        self.totalNumberOfRecords += result.numberReturned;\n\n        // Determine if there's more documents to fetch\n        if(result.numberReturned > 0) {\n          if (self.limitValue > 0) {\n            var excessResult = self.totalNumberOfRecords - self.limitValue;\n\n            if (excessResult > 0) {\n              result.documents.splice(-1 * excessResult, excessResult);\n            }\n          }\n\n          // Reset the tries for awaitdata if we are using it\n          self.currentNumberOfRetries = self.numberOfRetries;\n          // Get the documents\n          for(var i = 0; i < result.documents.length; i++) {\n            self.items.push(result.documents[i]);\n          }\n\n          // result = null;\n          callback(null, self.items.shift());\n        } else if(self.tailable && !isDead && self.awaitdata) {\n          // Excute the tailable cursor once more, will timeout after ~4 sec if awaitdata used\n          self.currentNumberOfRetries = self.currentNumberOfRetries - 1;\n          if(self.currentNumberOfRetries == 0) {\n            self.close(function() {\n              callback(new Error(\"tailable cursor timed out\"), null);\n            });\n          } else {\n            process.nextTick(function() { getMore(self, callback); });\n          }\n        } else if(self.tailable && !isDead) {\n          self.getMoreTimer = setTimeout(function() { getMore(self, callback); }, self.tailableRetryInterval);\n        } else {\n          self.close(function() {callback(null, null); });\n        }\n\n        result = null;\n      } catch(err) {\n        callback(err, null);\n      }\n    });\n\n    getMoreCommand = null;\n  } catch(err) {\n    var handleClose = function() {\n      callback(err, null);\n    };\n\n    self.close(handleClose);\n    handleClose = null;\n  }\n}\n\n/**\n * Gets a detailed information about how the query is performed on this cursor and how\n * long it took the database to process it.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will always be null while the second parameter will be an object containing the details.\n * @api public\n */\nCursor.prototype.explain = function(callback) {\n  var limit = (-1)*Math.abs(this.limitValue);\n\n // *  - **skip** {Number} skip number of documents to skip.\n // *  - **limit** {Number}, limit the number of results to return. -1 has a special meaning and is used by Db.eval. A value of 1 will also be treated as if it were -1.\n // *  - **hint**  {Object}, hint force the query to use a specific index.\n // *  - **explain** {Boolean}, explain return the explaination of the query.\n // *  - **slaveOk** {Boolean}, slaveOk, sets the slaveOk flag on the query wire protocol for secondaries.\n // *  - **snapshot** {Boolean}, snapshot Snapshot mode assures no duplicates are returned.\n // *  - **timeout** {Boolean}, timeout allow the query to timeout.\n // *  - **tailable** {Boolean}, tailable allow the cursor to be tailable.\n // *  - **awaitdata** {Boolean}, awaitdata allow the cursor to wait for data, only applicable for tailable cursor.\n // *  - **batchSize** {Number}, batchSize the number of the subset of results to request the database to return for every request. This should initially be greater than 1 otherwise the database will automatically close the cursor. The batch size can be set to 1 with cursorInstance.batchSize after performing the initial query to the database.\n // *  - **raw** {Boolean}, raw return all query documents as raw buffers (default false).\n // *  - **read** {Boolean}, read specify override of read from source (primary/secondary).\n // *  - **returnKey** {Boolean}, returnKey only return the index key.\n // *  - **maxScan** {Number}, maxScan limit the number of items to scan.\n // *  - **min** {Number}, min set index bounds.\n // *  - **max** {Number}, max set index bounds.\n // *  - **showDiskLoc** {Boolean}, showDiskLoc show disk location of results.\n // *  - **comment** {String}, comment you can put a $comment field on a query to make looking in the profiler logs simpler.\n // *  - **numberOfRetries** {Number}, numberOfRetries if using awaidata specifies the number of times to retry on timeout.\n // *  - **dbName** {String}, dbName override the default dbName.\n // *  - **tailableRetryInterval** {Number}, tailableRetryInterval specify the miliseconds between getMores on tailable cursor.\n // *  - **exhaust** {Boolean}, exhaust have the server send all the documents at once as getMore packets.\n // *  - **partial** {Boolean}, partial have the sharded system return a partial result from mongos.\n\n // *  - **sort** {Array | Object}, set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.\n\n// function Cursor(db, collection, selector, fields, skip, limit\n// -  , sort, hint, explain, snapshot, timeout, tailable, batchSize, slaveOk, raw, read\n// -  , returnKey, maxScan, min, max, showDiskLoc, comment, awaitdata, numberOfRetries, dbName, tailableRetry\n\n  // Create a new cursor and fetch the plan\n  var cursor = new Cursor(this.db, this.collection, this.selector, this.fields, {\n      skip: this.skipValue\n    , limit:limit\n    , sort: this.sortValue\n    , hint: this.hint\n    , explain: true\n    , snapshot: this.snapshot\n    , timeout: this.timeout\n    , tailable: this.tailable\n    , batchSize: this.batchSizeValue\n    , slaveOk: this.slaveOk\n    , raw: this.raw\n    , read: this.read\n    , returnKey: this.returnKey\n    , maxScan: this.maxScan\n    , min: this.min\n    , max: this.max\n    , showDiskLoc: this.showDiskLoc\n    , comment: this.comment\n    , awaitdata: this.awaitdata\n    , numberOfRetries: this.numberOfRetries\n    , dbName: this.dbName\n  });\n  \n  // Fetch the explaination document\n  cursor.nextObject(function(err, item) {\n    if(err != null) return callback(err, null);\n    // close the cursor\n    cursor.close(function(err, result) {\n      if(err != null) return callback(err, null);\n      callback(null, item);\n    });\n  });\n};\n\n/**\n * @ignore\n */\nCursor.prototype.streamRecords = function(options) {\n  console.log(\"[WARNING] streamRecords method is deprecated, please use stream method which is much faster\");\n  var args = Array.prototype.slice.call(arguments, 0);\n  options = args.length ? args.shift() : {};\n\n  var\n    self = this,\n    stream = new process.EventEmitter(),\n    recordLimitValue = this.limitValue || 0,\n    emittedRecordCount = 0,\n    queryCommand = generateQueryCommand(self);\n\n  // see http://www.mongodb.org/display/DOCS/Mongo+Wire+Protocol\n  queryCommand.numberToReturn = options.fetchSize ? options.fetchSize : 500;\n  // Execute the query\n  execute(queryCommand);\n\n  function execute(command) {\n    self.db._executeQueryCommand(command, {exhaust: self.exhaust, read:self.read, raw:self.raw, connection:self.connection}, function(err,result) {\n      if(err) {\n        stream.emit('error', err);\n        self.close(function(){});\n        return;\n      }\n\n      if (!self.queryRun && result) {\n        self.queryRun = true;\n        self.cursorId = result.cursorId;\n        self.state = Cursor.OPEN;\n        self.getMoreCommand = new GetMoreCommand(self.db, self.collectionName, queryCommand.numberToReturn, result.cursorId);\n      }\n\n      var resflagsMap = {\n        CursorNotFound:1<<0,\n        QueryFailure:1<<1,\n        ShardConfigStale:1<<2,\n        AwaitCapable:1<<3\n      };\n\n      if(result.documents && result.documents.length && !(result.responseFlag & resflagsMap.QueryFailure)) {\n        try {\n          result.documents.forEach(function(doc){\n            if(recordLimitValue && emittedRecordCount>=recordLimitValue) {\n              throw(\"done\");\n            }\n            emittedRecordCount++;\n            stream.emit('data', doc);\n          });\n        } catch(err) {\n          if (err != \"done\") { throw err; }\n          else {\n            self.close(function(){\n              stream.emit('end', recordLimitValue);\n            });\n            self.close(function(){});\n            return;\n          }\n        }\n        // rinse & repeat\n        execute(self.getMoreCommand);\n      } else {\n        self.close(function(){\n          stream.emit('end', recordLimitValue);\n        });\n      }\n    });\n  }\n\n  return stream;\n};\n\n/**\n * Returns a Node ReadStream interface for this cursor.\n *\n * @return {CursorStream} returns a stream object.\n * @api public\n */\nCursor.prototype.stream = function stream () {\n  return new CursorStream(this);\n}\n\n/**\n * Close the cursor.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will always contain null while the second parameter will contain a reference to this cursor.\n * @return {null}\n * @api public\n */\nCursor.prototype.close = function(callback) {\n  var self = this\n  this.getMoreTimer && clearTimeout(this.getMoreTimer);\n  // Close the cursor if not needed\n  if(this.cursorId instanceof Long && this.cursorId.greaterThan(Long.fromInt(0))) {\n    try {\n      var command = new KillCursorCommand(this.db, [this.cursorId]);\n      // Added an empty callback to ensure we don't throw any null exceptions\n      this.db._executeQueryCommand(command, {read:self.read, raw:self.raw, connection:self.connection}, function() {});\n    } catch(err) {}\n  }\n\n  // Null out the connection\n  self.connection = null;\n  // Reset cursor id\n  this.cursorId = Long.fromInt(0);\n  // Set to closed status\n  this.state = Cursor.CLOSED;\n\n  if(callback) {\n    callback(null, self);\n    self.items = [];\n  }\n\n  return this;\n};\n\n/**\n * Check if the cursor is closed or open.\n *\n * @return {Boolean} returns the state of the cursor.\n * @api public\n */\nCursor.prototype.isClosed = function() {\n  return this.state == Cursor.CLOSED ? true : false;\n};\n\n/**\n * Init state\n *\n * @classconstant INIT\n **/\nCursor.INIT = 0;\n\n/**\n * Cursor open\n *\n * @classconstant OPEN\n **/\nCursor.OPEN = 1;\n\n/**\n * Cursor closed\n *\n * @classconstant CLOSED\n **/\nCursor.CLOSED = 2;\n\n/**\n * @ignore\n * @api private\n */\nexports.Cursor =  Cursor;\n"]],"start1":0,"start2":0,"length1":0,"length2":33164}]],"length":33164}
