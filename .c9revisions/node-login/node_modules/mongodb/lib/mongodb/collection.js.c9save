{"ts":1354675590366,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Module dependencies.\n * @ignore\n */\nvar InsertCommand = require('./commands/insert_command').InsertCommand\n  , QueryCommand = require('./commands/query_command').QueryCommand\n  , DeleteCommand = require('./commands/delete_command').DeleteCommand\n  , UpdateCommand = require('./commands/update_command').UpdateCommand\n  , DbCommand = require('./commands/db_command').DbCommand\n  , ObjectID = require('bson').ObjectID\n  , Code = require('bson').Code\n  , Cursor = require('./cursor').Cursor\n  , utils = require('./utils');\n\n/**\n * Precompiled regexes\n * @ignore\n**/\nconst eErrorMessages = /No matching object found/;\n\n/**\n * toString helper.\n * @ignore\n */\nvar toString = Object.prototype.toString;\n\n/**\n * Create a new Collection instance\n *\n * Options\n *  - **slaveOk** {Boolean, default:false}, Allow reads from secondaries.\n *  - **serializeFunctions** {Boolean, default:false}, serialize functions on the document.\n *  - **raw** {Boolean, default:false}, perform all operations using raw bson objects.\n *  - **pkFactory** {Object}, object overriding the basic ObjectID primary key generation.\n *\n * @class Represents a Collection\n * @param {Object} db db instance.\n * @param {String} collectionName collection name.\n * @param {Object} [pkFactory] alternative primary key factory.\n * @param {Object} [options] additional options for the collection.\n * @return {Object} a collection instance.\n */\nfunction Collection (db, collectionName, pkFactory, options) {\n  if(!(this instanceof Collection)) return new Collection(db, collectionName, pkFactory, options);\n\n  checkCollectionName(collectionName);\n\n  this.db = db;\n  this.collectionName = collectionName;\n  this.internalHint = null;\n  this.opts = options != null && ('object' === typeof options) ? options : {};\n  this.slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;\n  this.serializeFunctions = options == null || options.serializeFunctions == null ? db.serializeFunctions : options.serializeFunctions;\n  this.raw = options == null || options.raw == null ? db.raw : options.raw;\n\n  this.readPreference = options == null || options.readPreference == null ? db.serverConfig.readPreference : options.readPreference;\n  this.readPreference = this.readPreference == null ? 'primary' : this.readPreference;\n\n  this.pkFactory = pkFactory == null\n    ? ObjectID\n    : pkFactory;\n\n  var self = this;\n}\n\n/**\n * Inserts a single document or a an array of documents into MongoDB.\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **continueOnError/keepGoing** {Boolean, default:false}, keep inserting documents even if one document has an error, *mongodb 1.9.1 >*.\n *  - **serializeFunctions** {Boolean, default:false}, serialize functions on the document.\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {Array|Object} docs\n * @param {Object} [options] optional options for insert command\n * @param {Function} [callback] optional callback for the function, must be provided when using a writeconcern\n * @return {null}\n * @api public\n */\nCollection.prototype.insert = function insert (docs, options, callback) {\n  if ('function' === typeof options) callback = options, options = {};\n  if(options == null) options = {};\n  if(!('function' === typeof callback)) callback = null;\n  var self = this;\n  insertAll(self, Array.isArray(docs) ? docs : [docs], options, callback);\n  return this;\n};\n\n/**\n * @ignore\n */\nvar checkCollectionName = function checkCollectionName (collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw Error(\"collection name must be a String\");\n  }\n\n  if (!collectionName || collectionName.indexOf('..') != -1) {\n    throw Error(\"collection names cannot be empty\");\n  }\n\n  if (collectionName.indexOf('$') != -1 &&\n      collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    throw Error(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw Error(\"collection names must not start or end with '.'\");\n  }\n};\n\n/**\n * Removes documents specified by `selector` from the db.\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **single** {Boolean, default:false}, removes the first document found.\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {Object} [selector] optional select, no selector is equivalent to removing all documents.\n * @param {Object} [options] additional options during remove.\n * @param {Function} [callback] must be provided if you performing a remove with a writeconcern\n * @return {null}\n * @api public\n */\nCollection.prototype.remove = function remove(selector, options, callback) {\n  if ('function' === typeof selector) {\n    callback = selector;\n    selector = options = {};\n  } else if ('function' === typeof options) {\n    callback = options;\n    options = {};\n  }\n\n  // Ensure options\n  if(options == null) options = {};\n  if(!('function' === typeof callback)) callback = null;\n  // Ensure we have at least an empty selector\n  selector = selector == null ? {} : selector;\n  // Set up flags for the command, if we have a single document remove\n  var flags = 0 | (options.single ? 1 : 0);\n\n  // DbName\n  var dbName = options['dbName'];\n  // If no dbname defined use the db one\n  if(dbName == null) {\n    dbName = this.db.databaseName;\n  }\n\n  // Create a delete command\n  var deleteCommand = new DeleteCommand(\n      this.db\n    , dbName + \".\" + this.collectionName\n    , selector\n    , flags);\n\n  var self = this;\n  var errorOptions = _getWriteConcern(self, options, callback);\n  // Execute the command, do not add a callback as it's async\n  if(_hasWriteConcern(errorOptions) && typeof callback == 'function') {\n    // Insert options\n    var commandOptions = {read:false};\n    // If we have safe set set async to false\n    if(errorOptions == null) commandOptions['async'] = true;\n    // Set safe option\n    commandOptions['safe'] = true;\n    // If we have an error option\n    if(typeof errorOptions == 'object') {\n      var keys = Object.keys(errorOptions);\n      for(var i = 0; i < keys.length; i++) {\n        commandOptions[keys[i]] = errorOptions[keys[i]];\n      }\n    }\n\n    // Execute command with safe options (rolls up both command and safe command into one and executes them on the same connection)\n    this.db._executeRemoveCommand(deleteCommand, commandOptions, function (err, error) {\n      error = error && error.documents;\n      if(!callback) return;\n\n      if(err) {\n        callback(err);\n      } else if(error[0].err || error[0].errmsg) {\n        callback(self.db.wrap(error[0]));\n      } else {\n        callback(null, error[0].n);\n      }\n    });\n  } else if(_hasWriteConcern(errorOptions) && callback == null) {\n    throw new Error(\"Cannot use a writeConcern without a provided callback\");\n  } else {\n    var result = this.db._executeRemoveCommand(deleteCommand);\n    // If no callback just return\n    if (!callback) return;\n    // If error return error\n    if (result instanceof Error) {\n      return callback(result);\n    }\n    // Otherwise just return\n    return callback();\n  }\n};\n\n/**\n * Renames the collection.\n *\n * @param {String} newName the new name of the collection.\n * @param {Function} callback the callback accepting the result\n * @return {null}\n * @api public\n */\nCollection.prototype.rename = function rename (newName, callback) {\n  var self = this;\n  // Ensure the new name is valid\n  checkCollectionName(newName);\n  // Execute the command, return the new renamed collection if successful\n  self.db._executeQueryCommand(DbCommand.createRenameCollectionCommand(self.db, self.collectionName, newName), function(err, result) {\n    if(err == null && result.documents[0].ok == 1) {\n      if(callback != null) {\n        // Set current object to point to the new name\n        self.collectionName = newName;\n        // Return the current collection\n        callback(null, self);\n      }\n    } else if(result.documents[0].errmsg != null) {\n      if(callback != null) {\n        err != null ? callback(err, null) : callback(self.db.wrap(result.documents[0]), null);\n      }\n    }\n  });\n};\n\n/**\n * @ignore\n */\nvar insertAll = function insertAll (self, docs, options, callback) {\n  if('function' === typeof options) callback = options, options = {};\n  if(options == null) options = {};\n  if(!('function' === typeof callback)) callback = null;\n\n  // Insert options (flags for insert)\n  var insertFlags = {};\n  // If we have a mongodb version >= 1.9.1 support keepGoing attribute\n  if(options['keepGoing'] != null) {\n    insertFlags['keepGoing'] = options['keepGoing'];\n  }\n\n  // If we have a mongodb version >= 1.9.1 support keepGoing attribute\n  if(options['continueOnError'] != null) {\n    insertFlags['continueOnError'] = options['continueOnError'];\n  }\n\n  // DbName\n  var dbName = options['dbName'];\n  // If no dbname defined use the db one\n  if(dbName == null) {\n    dbName = self.db.databaseName;\n  }\n\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n  if(options['serializeFunctions'] != null) {\n    insertFlags['serializeFunctions'] = options['serializeFunctions'];\n  } else {\n    insertFlags['serializeFunctions'] = self.serializeFunctions;\n  }\n\n  // Pass in options\n  var insertCommand = new InsertCommand(\n      self.db\n    , dbName + \".\" + self.collectionName, true, insertFlags);\n\n  // Add the documents and decorate them with id's if they have none\n  for(var index = 0, len = docs.length; index < len; ++index) {\n    var doc = docs[index];\n\n    // Add id to each document if it's not already defined\n    if (!(Buffer.isBuffer(doc)) && doc['_id'] == null && self.db.forceServerObjectId != true) {\n      doc['_id'] = self.pkFactory.createPk();\n    }\n\n    insertCommand.add(doc);\n  }\n\n  // Collect errorOptions\n  var errorOptions = _getWriteConcern(self, options, callback);\n  // Default command options\n  var commandOptions = {};\n  // If safe is defined check for error message\n  if(_hasWriteConcern(errorOptions) && typeof callback == 'function') {\n    // Insert options\n    commandOptions['read'] = false;\n    // If we have safe set set async to false\n    if(errorOptions == null) commandOptions['async'] = true;\n\n    // Set safe option\n    commandOptions['safe'] = errorOptions;\n    // If we have an error option\n    if(typeof errorOptions == 'object') {\n      var keys = Object.keys(errorOptions);\n      for(var i = 0; i < keys.length; i++) {\n        commandOptions[keys[i]] = errorOptions[keys[i]];\n      }\n    }\n\n    // Execute command with safe options (rolls up both command and safe command into one and executes them on the same connection)\n    self.db._executeInsertCommand(insertCommand, commandOptions, function (err, error) {\n      error = error && error.documents;\n      if(!callback) return;\n\n      if (err) {\n        callback(err);\n      } else if(error[0].err || error[0].errmsg) {\n        callback(self.db.wrap(error[0]));\n      } else {\n        callback(null, docs);\n      }\n    });\n  } else if(_hasWriteConcern(errorOptions) && callback == null) {\n    throw new Error(\"Cannot use a writeConcern without a provided callback\");\n  } else {\n    // Execute the call without a write concern\n    var result = self.db._executeInsertCommand(insertCommand, commandOptions);\n    // If no callback just return\n    if(!callback) return;\n    // If error return error\n    if(result instanceof Error) {\n      return callback(result);\n    }\n    // Otherwise just return\n    return callback(null, docs);\n  }\n};\n\n/**\n * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic\n * operators and update instead for more efficient operations.\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {Object} [doc] the document to save\n * @param {Object} [options] additional options during remove.\n * @param {Function} [callback] must be provided if you performing a safe save\n * @return {null}\n * @api public\n */\nCollection.prototype.save = function save(doc, options, callback) {\n  if('function' === typeof options) callback = options, options = null;\n  if(options == null) options = {};\n  if(!('function' === typeof callback)) callback = null;\n  // Extract the id, if we have one we need to do a update command\n  var id = doc['_id'];\n  var commandOptions = _getWriteConcern(this, options, callback);\n\n  if(id) {\n    commandOptions.upsert = true;\n    this.update({ _id: id }, doc, commandOptions, callback);\n  } else {\n    this.insert(doc, commandOptions, callback && function (err, docs) {\n      if (err) return callback(err, null);\n\n      if (Array.isArray(docs)) {\n        callback(err, docs[0]);\n      } else {\n        callback(err, docs);\n      }\n    });\n  }\n};\n\n/**\n * Updates documents.\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **upsert** {Boolean, default:false}, perform an upsert operation.\n *  - **multi** {Boolean, default:false}, update all documents matching the selector.\n *  - **serializeFunctions** {Boolean, default:false}, serialize functions on the document.\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {Object} selector the query to select the document/documents to be updated\n * @param {Object} document the fields/vals to be updated, or in the case of an upsert operation, inserted.\n * @param {Object} [options] additional options during update.\n * @param {Function} [callback] must be provided if you performing an update with a writeconcern\n * @return {null}\n * @api public\n */\nCollection.prototype.update = function update(selector, document, options, callback) {\n  if('function' === typeof options) callback = options, options = null;\n  if(options == null) options = {};\n  if(!('function' === typeof callback)) callback = null;\n\n  // DbName\n  var dbName = options['dbName'];\n  // If no dbname defined use the db one\n  if(dbName == null) {\n    dbName = this.db.databaseName;\n  }\n\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n  if(options['serializeFunctions'] != null) {\n    options['serializeFunctions'] = options['serializeFunctions'];\n  } else {\n    options['serializeFunctions'] = this.serializeFunctions;\n  }\n\n  var updateCommand = new UpdateCommand(\n      this.db\n    , dbName + \".\" + this.collectionName\n    , selector\n    , document\n    , options);\n\n  var self = this;\n  // Unpack the error options if any\n  var errorOptions = _getWriteConcern(this, options, callback);\n  // If safe is defined check for error message\n  if(_hasWriteConcern(errorOptions) && typeof callback == 'function') {\n    // Insert options\n    var commandOptions = {read:false};\n    // If we have safe set set async to false\n    if(errorOptions == null) commandOptions['async'] = true;\n    // Set safe option\n    commandOptions['safe'] = errorOptions;\n    // If we have an error option\n    if(typeof errorOptions == 'object') {\n      var keys = Object.keys(errorOptions);\n      for(var i = 0; i < keys.length; i++) {\n        commandOptions[keys[i]] = errorOptions[keys[i]];\n      }\n    }\n\n    // Execute command with safe options (rolls up both command and safe command into one and executes them on the same connection)\n    this.db._executeUpdateCommand(updateCommand, commandOptions, function (err, error) {\n      error = error && error.documents;\n      if(!callback) return;\n\n      if(err) {\n        callback(err);\n      } else if(error[0].err || error[0].errmsg) {\n        callback(self.db.wrap(error[0]));\n      } else {\n        // Perform the callback\n        callback(null, error[0].n, error[0]);\n      }\n    });\n  } else if(_hasWriteConcern(errorOptions) && callback == null) {\n    throw new Error(\"Cannot use a writeConcern without a provided callback\");\n  } else {\n    // Execute update\n    var result = this.db._executeUpdateCommand(updateCommand);\n    // If no callback just return\n    if (!callback) return;\n    // If error return error\n    if (result instanceof Error) {\n      return callback(result);\n    }\n    // Otherwise just return\n    return callback();\n  }\n};\n\n/**\n * The distinct command returns returns a list of distinct values for the given key across a collection.\n *\n * Options\n *  - **readPreference** {String}, the preferred read preference (Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {String} key key to run distinct against.\n * @param {Object} [query] option query to narrow the returned objects.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from distinct or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.distinct = function distinct(key, query, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  query = args.length ? args.shift() : {};\n  options = args.length ? args.shift() : {};\n\n  var mapCommandHash = {\n      'distinct': this.collectionName\n    , 'query': query\n    , 'key': key\n  };\n\n  // Set read preference if we set one\n  var readPreference = options['readPreference'] ? options['readPreference'] : false;\n  // Create the command\n  var cmd = DbCommand.createDbSlaveOkCommand(this.db, mapCommandHash);\n\n  this.db._executeQueryCommand(cmd, {read:readPreference}, function (err, result) {\n    if(err)\n      return callback(err);\n    if(result.documents[0].ok != 1)\n      return callback(new Error(result.documents[0].errmsg));\n    callback(null, result.documents[0].values);\n  });\n};\n\n/**\n * Count number of matching documents in the db to a query.\n *\n * Options\n *  - **readPreference** {String}, the preferred read preference (Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {Object} [query] query to filter by before performing count.\n * @param {Object} [options] additional options during count.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the count method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.count = function count (query, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  query = args.length ? args.shift() : {};\n  options = args.length ? args.shift() : {};\n\n  // Final query\n  var final_query = {\n      'count': this.collectionName\n    , 'query': query\n    , 'fields': null\n  };\n\n  // Set read preference if we set one\n  var readPreference = options['readPreference'] ? options['readPreference'] : false;\n\n  // Set up query options\n  var queryOptions = QueryCommand.OPTS_NO_CURSOR_TIMEOUT;\n  if (this.slaveOk || this.db.slaveOk) {\n    queryOptions |= QueryCommand.OPTS_SLAVE;\n  }\n\n  var queryCommand = new QueryCommand(\n      this.db\n    , this.db.databaseName + \".$cmd\"\n    , queryOptions\n    , 0\n    , -1\n    , final_query\n    , null\n  );\n\n  var self = this;\n  this.db._executeQueryCommand(queryCommand, {read:readPreference}, function (err, result) {\n    result = result && result.documents;\n    if(!callback) return;\n\n    if(err) return callback(err);\n    if (result[0].ok != 1 || result[0].errmsg) return callback(self.db.wrap(result[0]));\n    callback(null, result[0].n);\n  });\n};\n\n\n/**\n * Drop the collection\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the drop method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.drop = function drop(callback) {\n  this.db.dropCollection(this.collectionName, callback);\n};\n\n/**\n * Find and update a document.\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **remove** {Boolean, default:false}, set to true to remove the object before returning.\n *  - **upsert** {Boolean, default:false}, perform an upsert operation.\n *  - **new** {Boolean, default:false}, set to true if you want to return the modified object rather than the original. Ignored for remove.\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {Object} query query object to locate the object to modify\n * @param {Array}  sort - if multiple docs match, choose the first one in the specified sort order as the object to manipulate\n * @param {Object} doc - the fields/vals to be updated\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the findAndModify method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.findAndModify = function findAndModify (query, sort, doc, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  sort = args.length ? args.shift() : [];\n  doc = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : {};\n  var self = this;\n\n  var queryObject = {\n      'findandmodify': this.collectionName\n    , 'query': query\n    , 'sort': utils.formattedOrderClause(sort)\n  };\n\n  queryObject.new = options.new ? 1 : 0;\n  queryObject.remove = options.remove ? 1 : 0;\n  queryObject.upsert = options.upsert ? 1 : 0;\n\n  if (options.fields) {\n    queryObject.fields = options.fields;\n  }\n\n  if (doc && !options.remove) {\n    queryObject.update = doc;\n  }\n\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n  if(options['serializeFunctions'] != null) {\n    options['serializeFunctions'] = options['serializeFunctions'];\n  } else {\n    options['serializeFunctions'] = this.serializeFunctions;\n  }\n\n  // Unpack the error options if any\n  var errorOptions = _getWriteConcern(this, options, callback);\n\n  // If we have j, w or something else do the getLast Error path\n  if(errorOptions != null && typeof errorOptions == 'object') {\n    // Commands to send\n    var commands = [];\n    // Add the find and modify command\n    commands.push(DbCommand.createDbCommand(this.db, queryObject, options));\n    // If we have safe defined we need to return both call results\n    var chainedCommands = errorOptions != null ? true : false;\n    // Add error command if we have one\n    if(chainedCommands) {\n      commands.push(DbCommand.createGetLastErrorCommand(errorOptions, this.db));\n    }\n\n    // Fire commands and\n    this.db._executeQueryCommand(commands, {read:false}, function(err, result) {\n      if(err != null) return callback(err);\n      result = result && result.documents;\n\n      if(result[0].err != null) return callback(self.db.wrap(result[0]), null);\n      // Workaround due to 1.8.X returning an error on no matching object\n      // while 2.0.X does not not, making 2.0.X behaviour standard\n      if(result[0].errmsg != null && !result[0].errmsg.match(eErrorMessages))\n        return callback(self.db.wrap(result[0]), null, result[0]);\n      return callback(null, result[0].value, result[0]);\n    });\n  } else {\n    // Only run command and rely on getLastError command\n    var command = DbCommand.createDbCommand(this.db, queryObject, options)\n    // Execute command\n    this.db._executeQueryCommand(command, {read:false}, function(err, result) {\n      if(err != null) return callback(err);\n      result = result && result.documents;\n      if(result[0].errmsg != null && !result[0].errmsg.match(eErrorMessages))\n        return callback(self.db.wrap(result[0]), null, result[0]);\n      // If we have an error return it\n      if(result[0].lastErrorObject && result[0].lastErrorObject.err != null) return callback(self.db.wrap(result[0].lastErrorObject), null);\n      return callback(null, result[0].value, result[0]);\n    });\n  }\n}\n\n/**\n * Find and remove a document\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {Object} query query object to locate the object to modify\n * @param {Array}  sort - if multiple docs match, choose the first one in the specified sort order as the object to manipulate\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the findAndRemove method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.findAndRemove = function(query, sort, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  sort = args.length ? args.shift() : [];\n  options = args.length ? args.shift() : {};\n  // Add the remove option\n  options['remove'] = true;\n  // Execute the callback\n  this.findAndModify(query, sort, null, options, callback);\n}\n\nvar testForFields = {\n    limit: 1, sort: 1, fields:1, skip: 1, hint: 1, explain: 1, snapshot: 1, timeout: 1, tailable: 1, tailableRetryInterval: 1\n  , numberOfRetries: 1, awaitdata: 1, exhaust: 1, batchSize: 1, returnKey: 1, maxScan: 1, min: 1, max: 1, showDiskLoc: 1\n  , comment: 1, raw: 1, readPreference: 1, numberOfRetries: 1, partial: 1, read: 1, dbName: 1\n};\n\n/**\n * Creates a cursor for a query that can be used to iterate over results from MongoDB\n *\n * Various argument possibilities\n *  - callback?\n *  - selector, callback?,\n *  - selector, fields, callback?\n *  - selector, options, callback?\n *  - selector, fields, options, callback?\n *  - selector, fields, skip, limit, callback?\n *  - selector, fields, skip, limit, timeout, callback?\n *\n * Options\n *  - **limit** {Number, default:0}, sets the limit of documents returned in the query.\n *  - **sort** {Array | Object}, set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.\n *  - **fields** {Object}, the fields to return in the query. Object of fields to include or exclude (not both), {'a':1}\n *  - **skip** {Number, default:0}, set to skip N documents ahead in your query (useful for pagination).\n *  - **hint** {Object}, tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}\n *  - **explain** {Boolean, default:false}, explain the query instead of returning the data.\n *  - **snapshot** {Boolean, default:false}, snapshot query.\n *  - **timeout** {Boolean, default:false}, specify if the cursor can timeout.\n *  - **tailable** {Boolean, default:false}, specify if the cursor is tailable.\n *  - **tailableRetryInterval** {Number, default:100}, specify the miliseconds between getMores on tailable cursor.\n *  - **numberOfRetries** {Number, default:5}, specify the number of times to retry the tailable cursor.\n *  - **awaitdata** {Boolean, default:false} allow the cursor to wait for data, only applicable for tailable cursor.\n *  - **exhaust** {Boolean, default:false} have the server send all the documents at once as getMore packets, not recommended.\n *  - **batchSize** {Number, default:0}, set the batchSize for the getMoreCommand when iterating over the query results.\n *  - **returnKey** {Boolean, default:false}, only return the index key.\n *  - **maxScan** {Number}, Limit the number of items to scan.\n *  - **min** {Number}, Set index bounds.\n *  - **max** {Number}, Set index bounds.\n *  - **showDiskLoc** {Boolean, default:false}, Show disk location of results.\n *  - **comment** {String}, You can put a $comment field on a query to make looking in the profiler logs simpler.\n *  - **raw** {Boolean, default:false}, Return all BSON documents as Raw Buffer documents.\n *  - **readPreference** {String}, the preferred read preference ((Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *  - **numberOfRetries** {Number, default:5}, if using awaidata specifies the number of times to retry on timeout.\n *  - **partial** {Boolean, default:false}, specify if the cursor should return partial results when querying against a sharded system\n *\n * @param {Object} query query object to locate the object to modify\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the find method or null if an error occured.\n * @return {Cursor} returns a cursor to the query\n * @api public\n */\nCollection.prototype.find = function find () {\n  var options\n    , args = Array.prototype.slice.call(arguments, 0)\n    , has_callback = typeof args[args.length - 1] === 'function'\n    , has_weird_callback = typeof args[0] === 'function'\n    , callback = has_callback ? args.pop() : (has_weird_callback ? args.shift() : null)\n    , len = args.length\n    , selector = len >= 1 ? args[0] : {}\n    , fields = len >= 2 ? args[1] : undefined;\n\n  if(len === 1 && has_weird_callback) {\n    // backwards compat for callback?, options case\n    selector = {};\n    options = args[0];\n  }\n\n  if(len === 2 && !Array.isArray(fields)) {\n    var fieldKeys = Object.getOwnPropertyNames(fields);\n    var is_option = false;\n\n    for(var i = 0; i < fieldKeys.length; i++) {\n      if(testForFields[fieldKeys[i]] != null) {\n        is_option = true;\n        break;\n      }\n    }\n\n    if(is_option) {\n      options = fields;\n      fields = undefined;\n    } else {\n      options = {};\n    }\n  } else if(len === 2 && Array.isArray(fields) && !Array.isArray(fields[0])) {\n    var newFields = {};\n    // Rewrite the array\n    for(var i = 0; i < fields.length; i++) {\n      newFields[fields[i]] = 1;\n    }\n    // Set the fields\n    fields = newFields;\n  }\n\n  if(3 === len) {\n    options = args[2];\n  }\n\n  // Ensure selector is not null\n  selector = selector == null ? {} : selector;\n  // Validate correctness off the selector\n  var object = selector;\n  if(Buffer.isBuffer(object)) {\n    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;\n    if(object_size != object.length)  {\n      var error = new Error(\"query selector raw message size does not match message header size [\" + object.length + \"] != [\" + object_size + \"]\");\n      error.name = 'MongoError';\n      throw error;\n    }\n  }\n\n  // Validate correctness of the field selector\n  var object = fields;\n  if(Buffer.isBuffer(object)) {\n    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;\n    if(object_size != object.length)  {\n      var error = new Error(\"query fields raw message size does not match message header size [\" + object.length + \"] != [\" + object_size + \"]\");\n      error.name = 'MongoError';\n      throw error;\n    }\n  }\n\n  // Check special case where we are using an objectId\n  if(selector instanceof ObjectID) {\n    selector = {_id:selector};\n  }\n\n  // If it's a serialized fields field we need to just let it through\n  // user be warned it better be good\n  if(options && options.fields && !(Buffer.isBuffer(options.fields))) {\n    fields = {};\n\n    if(Array.isArray(options.fields)) {\n      if(!options.fields.length) {\n        fields['_id'] = 1;\n      } else {\n        for (var i = 0, l = options.fields.length; i < l; i++) {\n          fields[options.fields[i]] = 1;\n        }\n      }\n    } else {\n      fields = options.fields;\n    }\n  }\n\n  if (!options) options = {};\n  options.skip = len > 3 ? args[2] : options.skip ? options.skip : 0;\n  options.limit = len > 3 ? args[3] : options.limit ? options.limit : 0;\n  options.raw = options.raw != null && typeof options.raw === 'boolean' ? options.raw : this.raw;\n  options.hint = options.hint != null ? normalizeHintField(options.hint) : this.internalHint;\n  options.timeout = len == 5 ? args[4] : typeof options.timeout === 'undefined' ? undefined : options.timeout;\n  // If we have overridden slaveOk otherwise use the default db setting\n  options.slaveOk = options.slaveOk != null ? options.slaveOk : this.db.slaveOk;\n\n  // Set option\n  var o = options;\n  // Support read/readPreference\n  if(o[\"read\"] != null) o[\"readPreference\"] = o[\"read\"];\n  // Set the read preference\n  o.read = o[\"readPreference\"] ? o.readPreference : this.readPreference;\n  // Adjust slave ok if read preference is secondary or secondary only\n  if(o.read == \"secondary\" || o.read == \"secondaryOnly\") options.slaveOk = true;\n\n  // callback for backward compatibility\n  if(callback) {\n    // TODO refactor Cursor args\n    callback(null, new Cursor(this.db, this, selector, fields, o));\n  } else {\n    return new Cursor(this.db, this, selector, fields, o);\n  }\n};\n\n/**\n * Normalizes a `hint` argument.\n *\n * @param {String|Object|Array} hint\n * @return {Object}\n * @api private\n */\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (null != hint) {\n    switch (hint.constructor) {\n      case String:\n        finalHint = {};\n        finalHint[hint] = 1;\n        break;\n      case Object:\n        finalHint = {};\n        for (var name in hint) {\n          finalHint[name] = hint[name];\n        }\n        break;\n      case Array:\n        finalHint = {};\n        hint.forEach(function(param) {\n          finalHint[param] = 1;\n        });\n        break;\n    }\n  }\n\n  return finalHint;\n};\n\n/**\n * Finds a single document based on the query\n *\n * Various argument possibilities\n *  - callback?\n *  - selector, callback?,\n *  - selector, fields, callback?\n *  - selector, options, callback?\n *  - selector, fields, options, callback?\n *  - selector, fields, skip, limit, callback?\n *  - selector, fields, skip, limit, timeout, callback?\n *\n * Options\n *  - **limit** {Number, default:0}, sets the limit of documents returned in the query.\n *  - **sort** {Array | Object}, set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.\n *  - **fields** {Object}, the fields to return in the query. Object of fields to include or exclude (not both), {'a':1}\n *  - **skip** {Number, default:0}, set to skip N documents ahead in your query (useful for pagination).\n *  - **hint** {Object}, tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}\n *  - **explain** {Boolean, default:false}, explain the query instead of returning the data.\n *  - **snapshot** {Boolean, default:false}, snapshot query.\n *  - **timeout** {Boolean, default:false}, specify if the cursor can timeout.\n *  - **tailable** {Boolean, default:false}, specify if the cursor is tailable.\n *  - **batchSize** {Number, default:0}, set the batchSize for the getMoreCommand when iterating over the query results.\n *  - **returnKey** {Boolean, default:false}, only return the index key.\n *  - **maxScan** {Number}, Limit the number of items to scan.\n *  - **min** {Number}, Set index bounds.\n *  - **max** {Number}, Set index bounds.\n *  - **showDiskLoc** {Boolean, default:false}, Show disk location of results.\n *  - **comment** {String}, You can put a $comment field on a query to make looking in the profiler logs simpler.\n *  - **raw** {Boolean, default:false}, Return all BSON documents as Raw Buffer documents.\n *  - **readPreference** {String}, the preferred read preference (Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *  - **partial** {Boolean, default:false}, specify if the cursor should return partial results when querying against a sharded system\n *\n * @param {Object} query query object to locate the object to modify\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the findOne method or null if an error occured.\n * @return {Cursor} returns a cursor to the query\n * @api public\n */\nCollection.prototype.findOne = function findOne () {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  var cursor = this.find.apply(this, args).limit(-1).batchSize(1);\n  // Return the item\n  cursor.toArray(function(err, items) {\n    if(err != null) return callback(err instanceof Error ? err : self.db.wrap(new Error(err)), null);\n    if(items.length == 1) return callback(null, items[0]);\n    callback(null, null);\n  });\n};\n\n/**\n * Creates an index on the collection.\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **unique** {Boolean, default:false}, creates an unique index.\n *  - **sparse** {Boolean, default:false}, creates a sparse index.\n *  - **background** {Boolean, default:false}, creates the index in the background, yielding whenever possible.\n *  - **dropDups** {Boolean, default:false}, a unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n *  - **min** {Number}, for geospatial indexes set the lower bound for the co-ordinates.\n *  - **max** {Number}, for geospatial indexes set the high bound for the co-ordinates.\n *  - **v** {Number}, specify the format version of the indexes.\n *  - **expireAfterSeconds** {Number}, allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n *  - **name** {String}, override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {Object} fieldOrSpec fieldOrSpec that defines the index.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the createIndex method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.createIndex = function createIndex (fieldOrSpec, options, callback) {\n  // Clean up call\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n  options = typeof callback === 'function' ? options : callback;\n  options = options == null ? {} : options;\n\n  // Collect errorOptions\n  var errorOptions = _getWriteConcern(this, options, callback);\n  // Execute create index\n  this.db.createIndex(this.collectionName, fieldOrSpec, options, callback);\n};\n\n/**\n * Ensures that an index exists, if it does not it creates it\n *\n * Options\n*  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write\n *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)\n *  - **fsync**, (Boolean, default:false) write waits for fsync before returning\n *  - **journal**, (Boolean, default:false) write waits for journal sync before returning\n *  - **unique** {Boolean, default:false}, creates an unique index.\n *  - **sparse** {Boolean, default:false}, creates a sparse index.\n *  - **background** {Boolean, default:false}, creates the index in the background, yielding whenever possible.\n *  - **dropDups** {Boolean, default:false}, a unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n *  - **min** {Number}, for geospatial indexes set the lower bound for the co-ordinates.\n *  - **max** {Number}, for geospatial indexes set the high bound for the co-ordinates.\n *  - **v** {Number}, specify the format version of the indexes.\n *  - **expireAfterSeconds** {Number}, allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n *  - **name** {String}, override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * \n * Deprecated Options \n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {Object} fieldOrSpec fieldOrSpec that defines the index.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the ensureIndex method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.ensureIndex = function ensureIndex (fieldOrSpec, options, callback) {\n  // Clean up call\n  if (typeof callback === 'undefined' && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (options == null) {\n    options = {};\n  }\n\n  // Execute create index\n  this.db.ensureIndex(this.collectionName, fieldOrSpec, options, callback);\n};\n\n/**\n * Retrieves this collections index info.\n *\n * Options\n *  - **full** {Boolean, default:false}, returns the full raw index information.\n *\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the indexInformation method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.indexInformation = function indexInformation (options, callback) {\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n  // Call the index information\n  this.db.indexInformation(this.collectionName, options, callback);\n};\n\n/**\n * Drops an index from this collection.\n *\n * @param {String} name\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the dropIndex method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.dropIndex = function dropIndex (name, callback) {\n  this.db.dropIndex(this.collectionName, name, callback);\n};\n\n/**\n * Drops all indexes from this collection.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the dropAllIndexes method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.dropAllIndexes = function dropIndexes (callback) {\n  this.db.dropIndex(this.collectionName, '*', function (err, result) {\n    if(err != null) {\n      callback(err, false);\n    } else if(result.documents[0].errmsg == null) {\n      callback(null, true);\n    } else {\n      callback(new Error(result.documents[0].errmsg), false);\n    }\n  });\n};\n\n/**\n * Drops all indexes from this collection.\n *\n * @deprecated\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the dropIndexes method or null if an error occured.\n * @return {null}\n * @api private\n */\nCollection.prototype.dropIndexes = Collection.prototype.dropAllIndexes;\n\n/**\n * Reindex all indexes on the collection\n * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the reIndex method or null if an error occured.\n * @return {null}\n * @api public\n**/\nCollection.prototype.reIndex = function(callback) {\n  this.db.reIndex(this.collectionName, callback);\n}\n\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n *\n * Options\n *  - **out** {Object, default:*{inline:1}*}, sets the output target for the map reduce job. *{inline:1} | {replace:'collectionName'} | {merge:'collectionName'} | {reduce:'collectionName'}*\n *  - **query** {Object}, query filter object.\n *  - **sort** {Object}, sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.\n *  - **limit** {Number}, number of objects to return from collection.\n *  - **keeptemp** {Boolean, default:false}, keep temporary data.\n *  - **finalize** {Function | String}, finalize function.\n *  - **scope** {Object}, can pass in variables that can be access from map/reduce/finalize.\n *  - **jsMode** {Boolean, default:false}, it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.\n *  - **verbose** {Boolean, default:false}, provide statistics on job execution time.\n *  - **readPreference** {String, only for inline results}, the preferred read preference (Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {Function|String} map the mapping function.\n * @param {Function|String} reduce the reduce function.\n * @param {Objects} [options] options for the map reduce job.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the mapReduce method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.mapReduce = function mapReduce (map, reduce, options, callback) {\n  if ('function' === typeof options) callback = options, options = {};\n  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)\n  if(null == options.out) {\n    throw new Error(\"the out option parameter must be defined, see mongodb docs for possible values\");\n  }\n\n  if ('function' === typeof map) {\n    map = map.toString();\n  }\n\n  if ('function' === typeof reduce) {\n    reduce = reduce.toString();\n  }\n\n  if ('function' === typeof options.finalize) {\n    options.finalize = options.finalize.toString();\n  }\n\n  var mapCommandHash = {\n      mapreduce: this.collectionName\n    , map: map\n    , reduce: reduce\n  };\n\n  // Add any other options passed in\n  for (var name in options) {\n    mapCommandHash[name] = options[name];\n  }\n\n  // Set read preference if we set one\n  var readPreference = options['readPreference'] ? options['readPreference'] : false;\n  // If we have a read preference and inline is not set as output fail hard\n  if(readPreference != false && options['out'] != 'inline') {\n    throw new Error(\"a readPreference can only be provided when performing an inline mapReduce\");\n  }\n\n  // self\n  var self = this;\n  var cmd = DbCommand.createDbCommand(this.db, mapCommandHash);\n\n  this.db._executeQueryCommand(cmd, {read:readPreference}, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n\n    //\n    if (1 != result.documents[0].ok || result.documents[0].err || result.documents[0].errmsg) {\n      return callback(self.db.wrap(result.documents[0]));\n    }\n\n    // Create statistics value\n    var stats = {};\n    if(result.documents[0].timeMillis) stats['processtime'] = result.documents[0].timeMillis;\n    if(result.documents[0].counts) stats['counts'] = result.documents[0].counts;\n    if(result.documents[0].timing) stats['timing'] = result.documents[0].timing;\n\n    // invoked with inline?\n    if(result.documents[0].results) {\n      return callback(null, result.documents[0].results, stats);\n    }\n\n    // The returned collection\n    var collection = null;\n\n    // If we have an object it's a different db\n    if(result.documents[0].result != null && typeof result.documents[0].result == 'object') {\n      var doc = result.documents[0].result;\n      collection = self.db.db(doc.db).collection(doc.collection);\n    } else {\n      // Create a collection object that wraps the result collection\n      collection = self.db.collection(result.documents[0].result)\n    }\n\n    // If we wish for no verbosity\n    if(options['verbose'] == null || !options['verbose']) {\n      return callback(err, collection);\n    }\n\n    // Return stats as third set of values\n    callback(err, collection, stats);\n  });\n};\n\n/**\n * Group function helper\n * @ignore\n */\nvar groupFunction = function () {\n  var c = db[ns].find(condition);\n  var map = new Map();\n  var reduce_function = reduce;\n\n  while (c.hasNext()) {\n    var obj = c.next();\n    var key = {};\n\n    for (var i = 0, len = keys.length; i < len; ++i) {\n      var k = keys[i];\n      key[k] = obj[k];\n    }\n\n    var aggObj = map.get(key);\n\n    if (aggObj == null) {\n      var newObj = Object.extend({}, key);\n      aggObj = Object.extend(newObj, initial);\n      map.put(key, aggObj);\n    }\n\n    reduce_function(obj, aggObj);\n  }\n\n  return { \"result\": map.values() };\n}.toString();\n\n/**\n * Run a group command across a collection\n  *\n * Options\n *  - **readPreference** {String}, the preferred read preference (Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {Object|Array|Function|Code} keys an object, array or function expressing the keys to group by.\n * @param {Object} condition an optional condition that must be true for a row to be considered.\n * @param {Object} initial initial value of the aggregation counter object.\n * @param {Function|Code} reduce the reduce function aggregates (reduces) the objects iterated\n * @param {Function|Code} finalize an optional function to be run on each item in the result set just before the item is returned.\n * @param {Boolean} command specify if you wish to run using the internal group command or using eval, default is true.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the group method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.group = function group(keys, condition, initial, reduce, finalize, command, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 3);\n  callback = args.pop();\n  // Fetch all commands\n  reduce = args.length ? args.shift() : null;\n  finalize = args.length ? args.shift() : null;\n  command = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : {};\n\n  // Make sure we are backward compatible\n  if(!(typeof finalize == 'function')) {\n    command = finalize;\n    finalize = null;\n  }\n\n  if (!Array.isArray(keys) && keys instanceof Object && typeof(keys) !== 'function' && !(keys instanceof Code)) {\n    keys = Object.keys(keys);\n  }\n\n  if(typeof reduce === 'function') {\n    reduce = reduce.toString();\n  }\n\n  if(typeof finalize === 'function') {\n    finalize = finalize.toString();\n  }\n\n  // Set up the command as default\n  command = command == null ? true : command;\n\n  // Execute using the command\n  if(command) {\n    var reduceFunction = reduce instanceof Code\n        ? reduce\n        : new Code(reduce);\n\n    var selector = {\n      group: {\n          'ns': this.collectionName\n        , '$reduce': reduceFunction\n        , 'cond': condition\n        , 'initial': initial\n        , 'out': \"inline\"\n      }\n    };\n\n    // if finalize is defined\n    if(finalize != null) selector.group['finalize'] = finalize;\n    // Set up group selector\n    if ('function' === typeof keys || keys instanceof Code) {\n      selector.group.$keyf = keys instanceof Code\n        ? keys\n        : new Code(keys);\n    } else {\n      var hash = {};\n      keys.forEach(function (key) {\n        hash[key] = 1;\n      });\n      selector.group.key = hash;\n    }\n\n    var cmd = DbCommand.createDbSlaveOkCommand(this.db, selector);\n    // Set read preference if we set one\n    var readPreference = options['readPreference'] ? options['readPreference'] : false;\n\n    this.db._executeQueryCommand(cmd, {read:readPreference}, function (err, result) {\n      if(err != null) return callback(err);\n\n      var document = result.documents[0];\n      if (null == document.retval) {\n        return callback(new Error(\"group command failed: \" + document.errmsg));\n      }\n\n      callback(null, document.retval);\n    });\n\n  } else {\n    // Create execution scope\n    var scope = reduce != null && reduce instanceof Code\n      ? reduce.scope\n      : {};\n\n    scope.ns = this.collectionName;\n    scope.keys = keys;\n    scope.condition = condition;\n    scope.initial = initial;\n\n    // Pass in the function text to execute within mongodb.\n    var groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');\n\n    this.db.eval(new Code(groupfn, scope), function (err, results) {\n      if (err) return callback(err, null);\n      callback(null, results.result || results);\n    });\n  }\n};\n\n/**\n * Returns the options of the collection.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the options method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.options = function options(callback) {\n  this.db.collectionsInfo(this.collectionName, function (err, cursor) {\n    if (err) return callback(err);\n    cursor.nextObject(function (err, document) {\n      callback(err, document && document.options || null);\n    });\n  });\n};\n\n/**\n * Returns if the collection is a capped collection\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the isCapped method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.isCapped = function isCapped(callback) {\n  this.options(function(err, document) {\n    if(err != null) {\n      callback(err);\n    } else {\n      callback(null, document && document.capped);\n    }\n  });\n};\n\n/**\n * Checks if one or more indexes exist on the collection\n *\n * @param {String|Array} indexNames check if one or more indexes exist on the collection.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the indexExists method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.indexExists = function indexExists(indexes, callback) {\n this.indexInformation(function(err, indexInformation) {\n   // If we have an error return\n   if(err != null) return callback(err, null);\n   // Let's check for the index names\n   if(Array.isArray(indexes)) {\n     for(var i = 0; i < indexes.length; i++) {\n       if(indexInformation[indexes[i]] == null) {\n         return callback(null, false);\n       }\n     }\n\n     // All keys found return true\n     return callback(null, true);\n   } else {\n     return callback(null, indexInformation[indexes] != null);\n   }\n });\n}\n\n/**\n * Execute the geoNear command to search for items in the collection\n *\n * Options\n *  - **num** {Number}, max number of results to return.\n *  - **maxDistance** {Number}, include results up to maxDistance from the point.\n *  - **distanceMultiplier** {Number}, include a value to multiply the distances with allowing for range conversions.\n *  - **query** {Object}, filter the results by a query.\n *  - **spherical** {Boolean, default:false}, perform query using a spherical model.\n *  - **uniqueDocs** {Boolean, default:false}, the closest location in a document to the center of the search region will always be returned MongoDB > 2.X.\n *  - **includeLocs** {Boolean, default:false}, include the location data fields in the top level of the results MongoDB > 2.X.\n *  - **readPreference** {String}, the preferred read preference ((Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {Number} x point to search on the x axis, ensure the indexes are ordered in the same order.\n * @param {Number} y point to search on the y axis, ensure the indexes are ordered in the same order.\n * @param {Objects} [options] options for the map reduce job.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the geoNear method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.geoNear = function geoNear(x, y, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();\n  // Fetch all commands\n  options = args.length ? args.shift() : {};\n\n  // Build command object\n  var commandObject = {\n    geoNear:this.collectionName,\n    near: [x, y]\n  }\n\n  // Decorate object if any with known properties\n  if(options['num'] != null) commandObject['num'] = options['num'];\n  if(options['maxDistance'] != null) commandObject['maxDistance'] = options['maxDistance'];\n  if(options['distanceMultiplier'] != null) commandObject['distanceMultiplier'] = options['distanceMultiplier'];\n  if(options['query'] != null) commandObject['query'] = options['query'];\n  if(options['spherical'] != null) commandObject['spherical'] = options['spherical'];\n  if(options['uniqueDocs'] != null) commandObject['uniqueDocs'] = options['uniqueDocs'];\n  if(options['includeLocs'] != null) commandObject['includeLocs'] = options['includeLocs'];\n\n  // Execute the command\n  this.db.command(commandObject, options, callback);\n}\n\n/**\n * Execute a geo search using a geo haystack index on a collection.\n *\n * Options\n *  - **maxDistance** {Number}, include results up to maxDistance from the point.\n *  - **search** {Object}, filter the results by a query.\n *  - **limit** {Number}, max number of results to return.\n *  - **readPreference** {String}, the preferred read preference ((Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {Number} x point to search on the x axis, ensure the indexes are ordered in the same order.\n * @param {Number} y point to search on the y axis, ensure the indexes are ordered in the same order.\n * @param {Objects} [options] options for the map reduce job.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the geoHaystackSearch method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.geoHaystackSearch = function geoHaystackSearch(x, y, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();\n  // Fetch all commands\n  options = args.length ? args.shift() : {};\n\n  // Build command object\n  var commandObject = {\n    geoSearch:this.collectionName,\n    near: [x, y]\n  }\n\n  // Decorate object if any with known properties\n  if(options['maxDistance'] != null) commandObject['maxDistance'] = options['maxDistance'];\n  if(options['query'] != null) commandObject['search'] = options['query'];\n  if(options['search'] != null) commandObject['search'] = options['search'];\n  if(options['limit'] != null) commandObject['limit'] = options['limit'];\n\n  // Execute the command\n  this.db.command(commandObject, options, callback);\n}\n\n/**\n * Retrieve all the indexes on the collection.\n *\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the indexes method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.indexes = function indexes(callback) {\n  // Return all the index information\n  this.db.indexInformation(this.collectionName, {full:true}, callback);\n}\n\n/**\n * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.1\n *\n * Options\n *  - **readPreference** {String}, the preferred read preference ((Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {Array} array containing all the aggregation framework commands for the execution.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the aggregate method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.aggregate = function(pipeline, options, callback) {\n  // *  - **explain** {Boolean}, return the query plan for the aggregation pipeline instead of the results. 2.3, 2.4\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  var self = this;\n\n  // If we have any of the supported options in the options object\n  var opts = args[args.length - 1];\n  options = opts.readPreference || opts.explain ? args.pop() : {}\n\n  // Convert operations to an array\n  if(!Array.isArray(args[0])) {\n    pipeline = [];\n    // Push all the operations to the pipeline\n    for(var i = 0; i < args.length; i++) pipeline.push(args[i]);\n  }\n\n  // Build the command\n  var command = { aggregate : this.collectionName, pipeline : pipeline};\n  // Add all options\n  var keys = Object.keys(options);\n  // Add all options\n  for(var i = 0; i < keys.length; i++) {\n    command[keys[i]] = options[keys[i]];\n  }\n\n  // Execute the command\n  this.db.command(command, options, function(err, result) {\n    if(err) {\n      callback(err);\n    } else if(result['err'] || result['errmsg']) {\n      callback(self.db.wrap(result));\n    } else if(typeof result == 'object' && result['serverPipeline']) {\n      callback(null, result);\n    } else {\n      callback(null, result.result);\n    }\n  });\n}\n\n/**\n * Get all the collection statistics.\n *\n * Options\n *  - **scale** {Number}, divide the returned sizes by scale value.\n *  - **readPreference** {String}, the preferred read preference ((Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {Objects} [options] options for the stats command.\n * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the stats method or null if an error occured.\n * @return {null}\n * @api public\n */\nCollection.prototype.stats = function stats(options, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  // Fetch all commands\n  options = args.length ? args.shift() : {};\n\n  // Build command object\n  var commandObject = {\n    collStats:this.collectionName,\n  }\n\n  // Check if we have the scale value\n  if(options['scale'] != null) commandObject['scale'] = options['scale'];\n\n  // Execute the command\n  this.db.command(commandObject, options, callback);\n}\n\n/**\n * @ignore\n */\nObject.defineProperty(Collection.prototype, \"hint\", {\n    enumerable: true\n  , get: function () {\n      return this.internalHint;\n    }\n  , set: function (v) {\n      this.internalHint = normalizeHintField(v);\n    }\n});\n\n/**\n * @ignore\n */\nvar _hasWriteConcern = function(errorOptions) {\n  return errorOptions == true\n    || errorOptions.w > 0\n    || errorOptions.w == 'majority'\n    || errorOptions.j == true\n    || errorOptions.journal == true\n    || errorOptions.fsync == true\n}\n\n/**\n * @ignore\n */\nvar _setWriteConcernHash = function(options) {\n  var finalOptions = {};\n  if(options.w != null) finalOptions.w = options.w;  \n  if(options.journal == true) finalOptions.j = options.journal;\n  if(options.j == true) finalOptions.j = options.j;\n  if(options.fsync == true) finalOptions.fsync = options.fsync;\n  if(options.wtimeout != null) finalOptions.wtimeout = options.wtimeout;  \n  return finalOptions;\n}\n\n/**\n * @ignore\n */\nvar _getWriteConcern = function(self, options, callback) {\n  // Final options\n  var finalOptions = {w:1};\n  // Local options verification\n  if(options.w != null || typeof options.j == 'boolean' || typeof options.journal == 'boolean' || typeof options.fsync == 'boolean') {\n    finalOptions = _setWriteConcernHash(options);\n  } else if(typeof options.safe == \"boolean\") {\n    finalOptions = {w: (options.safe ? 1 : 0)};\n  } else if(options.safe != null && typeof options.safe == 'object') {\n    finalOptions = _setWriteConcernHash(options.safe);\n  } else if(self.opts.w != null || typeof self.opts.j == 'boolean' || typeof self.opts.journal == 'boolean' || typeof self.opts.fsync == 'boolean') {\n    finalOptions = _setWriteConcernHash(self.opts);\n  } else if(typeof self.opts.safe == \"boolean\") {\n    finalOptions = {w: (self.opts.safe ? 1 : 0)};\n  } else if(self.db.safe.w != null || typeof self.db.safe.j == 'boolean' || typeof self.db.safe.journal == 'boolean' || typeof self.db.safe.fsync == 'boolean') {\n    finalOptions = _setWriteConcernHash(self.db.safe);\n  } else if(self.db.options.w != null || typeof self.db.options.j == 'boolean' || typeof self.db.options.journal == 'boolean' || typeof self.db.options.fsync == 'boolean') {\n    finalOptions = _setWriteConcernHash(self.db.options);\n  } else if(typeof self.db.safe == \"boolean\") {\n    finalOptions = {w: (self.db.safe ? 1 : 0)};\n  }\n\n  // Ensure we don't have an invalid combination of write concerns\n  if(finalOptions.w < 1 \n    && (finalOptions.journal == true || finalOptions.j == true || finalOptions.fsync == true)) throw new Error(\"No acknowlegement using w < 1 cannot be combined with journal:true or fsync:true\");\n\n  // Return the options\n  return finalOptions;\n}\n\n/**\n * Expose.\n */\nexports.Collection = Collection;"]],"start1":0,"start2":0,"length1":0,"length2":71005}]],"length":71005}
