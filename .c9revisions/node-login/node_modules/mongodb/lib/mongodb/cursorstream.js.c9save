{"ts":1354675586772,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Module dependecies.\n */\nvar Stream = require('stream').Stream;\n\n/**\n * CursorStream\n *\n * Returns a stream interface for the **cursor**.\n *\n * Events\n *  - **data** {function(item) {}} the data event triggers when a document is ready.\n *  - **error** {function(err) {}} the error event triggers if an error happens.\n *  - **close** {function() {}} the end event triggers when there is no more documents available.\n *\n * @class Represents a CursorStream.\n * @param {Cursor} cursor a cursor object that the stream wraps.\n * @return {Stream}\n */\nfunction CursorStream(cursor) {\n  if(!(this instanceof CursorStream)) return new CursorStream(cursor);\n\n  Stream.call(this);\n\n  this.readable = true;\n  this.paused = false;\n  this._cursor = cursor;\n  this._destroyed = null;\n\n  // give time to hook up events\n  var self = this;\n  process.nextTick(function () {\n    self._init();\n  });\n}\n\n/**\n * Inherit from Stream\n * @ignore\n * @api private\n */\nCursorStream.prototype.__proto__ = Stream.prototype;\n\n/**\n * Flag stating whether or not this stream is readable.\n */\nCursorStream.prototype.readable;\n\n/**\n * Flag stating whether or not this stream is paused.\n */\nCursorStream.prototype.paused;\n\n/**\n * Initialize the cursor.\n * @ignore\n * @api private\n */\nCursorStream.prototype._init = function () {\n  if (this._destroyed) return;\n  this._next();\n}\n\n/**\n * Pull the next document from the cursor.\n * @ignore\n * @api private\n */\nCursorStream.prototype._next = function () {\n  if (this.paused || this._destroyed) return;\n\n  var self = this;\n\n  // nextTick is necessary to avoid stack overflows when\n  // dealing with large result sets.\n  process.nextTick(function () {\n    self._cursor.nextObject(function (err, doc) {\n      self._onNextObject(err, doc);\n    });\n  });\n}\n\n/**\n * Handle each document as its returned from the cursor.\n * @ignore\n * @api private\n */\nCursorStream.prototype._onNextObject = function (err, doc) {\n  if (err) return this.destroy(err);\n\n  // when doc is null we hit the end of the cursor\n  if (!doc) {\n    this.emit('end')\n    return this.destroy();\n  }\n\n  this.emit('data', doc);\n  this._next();\n}\n\n/**\n * Pauses the stream.\n *\n * @api public\n */\nCursorStream.prototype.pause = function () {\n  this.paused = true;\n}\n\n/**\n * Resumes the stream.\n *\n * @api public\n */\nCursorStream.prototype.resume = function () {\n  var self = this;\n  process.nextTick(function() {\n    self.paused = false;\n    self._next();\n  })\n}\n\n/**\n * Destroys the stream, closing the underlying\n * cursor. No more events will be emitted.\n *\n * @api public\n */\nCursorStream.prototype.destroy = function (err) {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  this.readable = false;\n\n  this._cursor.close();\n\n  if (err) {\n    this.emit('error', err);\n  }\n\n  this.emit('close');\n}\n\n// TODO - maybe implement the raw option to pass binary?\n//CursorStream.prototype.setEncoding = function () {\n//}\n\nmodule.exports = exports = CursorStream;\n"]],"start1":0,"start2":0,"length1":0,"length2":2938}]],"length":2938}
